package de.grogra.mtg;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;

import de.grogra.graph.Graph;
import de.grogra.graph.impl.Edge;
import de.grogra.graph.impl.Node;
import de.grogra.graph.impl.Node.NType;
import de.grogra.imp3d.View3D;
import de.grogra.imp3d.io.SceneGraphExport;
import de.grogra.imp3d.objects.SceneTree;
import de.grogra.imp3d.objects.SceneTree.InnerNode;
import de.grogra.mtg.MTGError.MTGExportException;
import de.grogra.pf.io.FileWriterSource;
import de.grogra.pf.io.FilterItem;
import de.grogra.pf.io.FilterSource;
import de.grogra.pf.io.IOFlavor;
import de.grogra.pf.registry.PluginDescriptor;
import de.grogra.pf.registry.Registry;
import de.grogra.pf.ui.Workbench;
import de.grogra.reflect.Field;
import de.grogra.reflect.Method;
import de.grogra.reflect.Type;
import de.grogra.util.MimeType;

public class MTGExport  extends SceneGraphExport implements FileWriterSource {
	
	//buffer for mtg file contents
	private ArrayList<String> code;
	private ArrayList<ArrayList<String> > classes;
	private ArrayList<String> description;
	private ArrayList<String> features;
	private ArrayList<String> mtg;

	//GroIMP node classes encountered and the corresponding MTG class names for export
	private ArrayList<ArrayList<String> >classesGroIMP;
	private ArrayList<ArrayList<String> > classesMTG;
	
	//GroIMP node fields for export
	private ArrayList<String> fieldsGroIMP;

	//GroIMP edges encountered
	//private ArrayList<Integer> edgesGroIMP;

	//latest nodes from each scale encountered during traversal
	private ArrayList<Node> latest;

	//stack for recording latest bifurcation points
	private ArrayList< ArrayList<Node> > stack;
	private ArrayList<Integer> stackLastTrav; //last traversed node at the recorded bifurcation point
	private int maxStackSize;

	//current traversal scale
	private int scale;

	//last assigned MTG class symbol ascii code
	private int symbolCode;

	//node number
	private int nodeId;
	
	private Workbench workbench = null;

	//NOTE: yong 31 may Error occurs on 2nd time export if this static IOFlavor is used
//	public static final IOFlavor FLAVOR
//	= new IOFlavor (new MimeType ("model/mtg", null),
//			IOFlavor.OUTPUT_STREAM, null);

	public MTGExport(FilterItem item, FilterSource source) {
		super(item, source);
		setFlavor (item.getOutputFlavor ()); //IOflavor retrieved from filter item each time
		this.workbench = Workbench.current();
		initContentBuffers();
	}

	private void initContentBufferCode()
	{
		code = new ArrayList<String>();
		code.add("#Generated by GroIMP " + ((PluginDescriptor) workbench.getRegistry ().getPluginDirectory ().getBranch ()).getPluginVersion());
		code.add("CODE:	FORM-A");
	}

	private void initContentBufferClasses()
	{
		classes = new ArrayList<ArrayList<String> >();
		ArrayList<String> zero = new ArrayList<String>();
		zero.add("CLASSES:");
		zero.add("SYMBOL	SCALE	DECOMPOSITION	INDEXATION	DEFINITION");
		zero.add("$ 	0	FREE	FREE	IMPLICIT");
		classes.add(zero);
	}

	private void initContentBufferDescription()
	{
		description = new ArrayList<String>();
		description.add("DESCRIPTION :");			
		description.add("LEFT	RIGHT	RELTYPE	MAX");
	}

	private void initContentBufferFeatures()
	{
		features = new ArrayList<String>();
		features.add("FEATURES:");
		features.add("NAME	TYPE");
	}

	private void initContentBufferMtg()
	{
		mtg = new ArrayList<String>();
		mtg.add("MTG:");
		mtg.add("");
		String ecLine = new String();
		ecLine += "ENTITY-CODE";
		int numTabs = maxStackSize+1;
		for(int i=0; i<numTabs; ++i)
			ecLine += "\t";
		for(int j=0; j<this.fieldsGroIMP.size(); ++j)
		{
			ecLine += fieldsGroIMP.get(j);
			if(j!=fieldsGroIMP.size()-1)
				ecLine += "\t";
		}
		mtg.add(ecLine);
	}

	private void initContentBuffers()
	{
		initContentBufferCode();
		initContentBufferClasses();
		initContentBufferDescription();
		initContentBufferFeatures();
		
		//initContentBufferMtg();		//delayed until after 1 round of graph traversal to 
										//determine number of features and tab characters to use
	}

	/**
	 * Initializes the temporary states and variables necessary for traversing the graph
	 */
	private void initStatesStacks()
	{
		classesGroIMP = new ArrayList<ArrayList<String> >();
		classesMTG  = new ArrayList<ArrayList<String> >();

		//GroIMP edges encountered
		//edgesGroIMP = new ArrayList<Integer>();
		
		fieldsGroIMP = new ArrayList<String>();

		//latest nodes from each scale encountered during traversal
		latest = new ArrayList<Node>();

		//stack for recording latest bifurcation points
		stack = new ArrayList< ArrayList<Node> >();
		stackLastTrav = new ArrayList<Integer>();
		maxStackSize = 0;

		//first scale is 1
		scale = 1;

		//first symbol for assigning is 65 'A';
		symbolCode = 65;

		//latest assigned node ID
		nodeId=0;
	}
	
	private void clearStatesStacks()
	{
		classesGroIMP.clear();
		classesMTG.clear();

		//GroIMP edges encountered
		//edgesGroIMP = new ArrayList<Integer>();

		//latest nodes from each scale encountered during traversal
		latest.clear();

		//stack for recording latest bifurcation points
		stack.clear();
		stackLastTrav.clear();

		//first scale is 1
		scale = 1;

		//first symbol for assigning is 65 'A';
		symbolCode = 65;

		//latest assigned node ID
		nodeId=0;
	}

	private int nextNodeId()
	{
		int currId=nodeId;
		nodeId++;
		return currId;
	}

	/**
	 * Create String Buffer containing content to be written to MTG file in its header section DESCRIPTION
	 */
	private void fillBufferDescription()
	{
		for(int i=0; i<this.classesMTG.size(); ++i)
		{
			ArrayList<String> currScale = classesMTG.get(i);
			for(int j=0; j<currScale.size(); ++j)
			{
				String currClass = currScale.get(j);
	
				//2 lines for each class - 1 for < relations, 1 for + relations
				String result="";
				String result2="";
	
				result+=currClass;
				result+="\t";
				result2+=currClass;
				result2+="\t";
	
				for(int k=0; k<currScale.size(); ++k)
				{
					result+=currScale.get(k);
					result2+=currScale.get(k);
	
					if(k!=currScale.size()-1)
					{
						result+=",";
						result2+=",";
					}
				}
	
				result+="\t";
				result2+="\t";
	
				result+="+";
				result2+="<";
	
				result+="\t";
				result2+="\t";
	
				result+="?";
				result2+="?";
	
				description.add(result);
				description.add(result2);
			}
		}
	}

	/**
	 * Initializes and begins traversal of the main project graph to fill the mtg content buffers
	 * @param r
	 * @throws MTGExportException 
	 */
	private void fillBuffers(Registry r) throws MTGExportException
	{
		//get root node of project graph from registry
		Node rootNode = r.getProjectGraph().getRoot();
		
		//do not begin at root node, but at the next node after the root
		for(Edge e = rootNode.getFirstEdge(); e!=null; e=e.getNext(rootNode))
		{
			if((e.getSource()==rootNode)&&(e.getTarget()!=rootNode))
			{
				rootNode = e.getTarget();
				break;
			}
		}

		//init traversal state variables and stacks
		initStatesStacks();
		
		//traverse the graph once to count total number of attributes export
		//this determines the number of 'tab' characters to use in 2nd line of MTG body section
		traverseGraph(rootNode,true);
		
		//clear state variables and stacks for 2nd traversal
		clearStatesStacks();
		
		//init buffers for features section in MTG header 
		//and MTG body section
		initContentBufferMtg();

		//traverse the graph again and fill buffers for MTG body
		traverseGraph(rootNode,false);

		//fill buffer for description section of MTG file
		fillBufferDescription();
	}

	private void pushStack(Node lastTraversed, int branchNum)
	{
		//copy entries at the bifurcation point
		ArrayList<Node> stackEntry = new ArrayList<Node>();
		for(int i=0; i<this.latest.size(); ++i)
		{
			stackEntry.add(this.latest.get(i));
		}
		//add bifurcation point to stack
		this.stack.add(stackEntry);

		//the last traversed node at the bifurcation point
		stackLastTrav.add(new Integer(branchNum));
	}

	private void popStack()
	{
		if(stack.size()<=0)
			return;

		ArrayList<Node> lastInStack = this.stack.get(this.stack.size()-1);
		this.stack.remove(this.stack.size()-1);

		for(int i=0; i<lastInStack.size(); ++i)
		{
			if(latest.size()-1<i)
			{
				latest.add(null);
			}

			latest.set(i, lastInStack.get(i));
		}

		//if bifurcation point has less scales than last traversed point,
		//set scale back to finest scale of popped bifurcation point
		//remove rest of the unused fine scales in latest
		if(latest.size() > lastInStack.size())
		{
			this.scale = lastInStack.size()-1;
			for(int j=latest.size()-1; j>lastInStack.size()-1; --j)
			{
				latest.remove(j);
			}
		}

		//current traversal scale becomes finest scale of popped stack entry
		this.scale = lastInStack.size()-1;
	}

	private int popStackLastTrav()
	{
		if(stackLastTrav.size()<=0)
			return -1;
		int lastTrav = this.stackLastTrav.get(stackLastTrav.size()-1).intValue();
		stackLastTrav.remove(stackLastTrav.size()-1);
		return lastTrav;
	}

	/**
	 * Stack-based, non-recursive traversal of graph.
	 * @param rootNode
	 * @throws MTGExportException
	 */
	private void traverseGraph(Node rootNode, boolean attributeCount) throws MTGExportException
	{
		Node currNode = rootNode;
		int currEdge = Graph.REFINEMENT_EDGE;
		int traversedToSkip = 0;
		boolean skipProcessing=false;

		while(currNode!=null)
		{
			//process the current node
			if(!skipProcessing) //if just restored bifurcation point from stack, skip processing
			{
				traverseNode(currEdge, currNode,attributeCount);
			}
			else //once processing is skipped, set flag back
				skipProcessing=false;

			boolean nextNodeFound=false;
			//find next node to traverse to
			//if there are refinements, go to refinements
			for(Edge e=currNode.getFirstEdge(); e!=null; e=e.getNext(currNode))
			{
				if((e.testEdgeBits(Graph.REFINEMENT_EDGE))&&(e.getSource()==currNode))
				{
					currNode = e.getTarget();
					currEdge = Graph.REFINEMENT_EDGE;
					this.scale++;
					nextNodeFound=true;
					break;
				}
			}
			if(nextNodeFound)
				continue;
			//else if there are no refinements, go to branches,
			int counter=0;
			for(Edge e=currNode.getFirstEdge(); e!=null; e=e.getNext(currNode))
			{
				if((e.testEdgeBits(Graph.BRANCH_EDGE))&&(e.getSource()==currNode))
				{
					counter++;
					if(traversedToSkip>0)
					{
						traversedToSkip--;
						continue;
					}

					//put current point of traversal into stack 
					pushStack(e.getTarget(),counter);

					//move on to the branched node
					currNode = e.getTarget();
					currEdge = Graph.BRANCH_EDGE;
					nextNodeFound=true;				
					break;
				}
			}
			if(nextNodeFound)
			{
				traversedToSkip=0;
				continue;
			}

			//else if there are no branches, go to successors
			for(Edge e=currNode.getFirstEdge(); e!=null; e=e.getNext(currNode))
			{
				if((e.testEdgeBits(Graph.SUCCESSOR_EDGE))&&(e.getSource()==currNode))
				{
					currNode = e.getTarget();
					currEdge = Graph.SUCCESSOR_EDGE;
					nextNodeFound=true;
					break;
				}
			}
			if(nextNodeFound)
			{
				traversedToSkip=0;
				continue;
			}

			//if no refinement,branch,successors, this node is end of branch.
			//pop the last bifurcation point from the stack and continue traversal from there
			popStack();
			traversedToSkip = popStackLastTrav();
			skipProcessing=true;
			if(currNode==latest.get(latest.size()-1)) //loop termination condition
				currNode=null;
			else
				currNode = latest.get(latest.size()-1);
		}
	}

	private void incrementSymbolCode() throws MTGExportException
	{
		symbolCode++;
		if(symbolCode==91)
			symbolCode=97;
		if(symbolCode>122)
			throw new MTGError.MTGExportException("Insufficient default class symbols.");

	}

	private String getNextSymbolCode() throws MTGExportException
	{
		String result = Character.toString((char)symbolCode);
		incrementSymbolCode();

		while(this.hasAssignedClass(result)!=-1)
		{
			result = Character.toString((char)symbolCode);
			incrementSymbolCode();
		}

		return result;
	}

	private String getMTGClassName(String groIMPClass) throws MTGExportException
	{
		if(groIMPClass==null)
			throw new MTGExportException("GroIMP class name is null.");

		if(groIMPClass.length()==0)
			throw new MTGExportException("GroIMP class name is empty string.");

		//if is generated mtg module, try to reuse alphabet after prefix
		if( (groIMPClass.contains(MTGKeys.MTG_MODULE_PREFIX)) && (groIMPClass.length()==5 ))
		{
			if(groIMPClass.substring(4, 5).matches("[a-zA-Z$]"))
			{
				String result = groIMPClass.substring(4, 5);
				if(hasAssignedClass(result)!=-1)
				{
					return getNextSymbolCode();
				}
				else
					return result;
			}
		}

		//try to use first character of groimp class name
		char firstChar = groIMPClass.charAt(0);
		if(Character.toString(firstChar).matches("[a-zA-Z$]"))
		{
			String result = groIMPClass.substring(0, 1);
			//if first character is already used, assign default class symbol in alphabetical order
			if(hasAssignedClass(result)!=-1)
			{
				return getNextSymbolCode();
			}
			else
				return result;
		}

		//assign default class symbol in alphabetical order
		return getNextSymbolCode();
	}

	/**
	 * For the input class name, create String Buffer containing content to be written to MTG file in its header section CLASSES
	 * @param className
	 * @param classScale
	 */
	private void addBufferClass(String className, int classScale)
	{
		int classesCount = classes.size();
		if(classesCount-1 < classScale)
		{
			for(int i=0; i< classScale-(classesCount-1) ; ++i)
			{
				classes.add(new ArrayList<String>());
			}
		}

		classes.get(classScale).add(className + "\t" + classScale + "\tFREE\tFREE\tEXPLICIT");
		
		classesCount = classesMTG.size();
		if(classesCount-1 < classScale)
		{
			for(int i=0; i< classScale-(classesCount-1) ; ++i)
			{
				classesMTG.add(new ArrayList<String>());
			}
		}

		classesMTG.get(classScale).add(className);
	}
	
	private boolean isStandardAttributeSet(Node node, String featureName) throws MTGExportException
	{
		boolean hasThisStdAtt=false;
		boolean isStdMTGAtt = MTGKeys.isStandardAttribute(featureName);
		if(isStdMTGAtt)
		{	
			Type currType = node.getNType();
			boolean flagMethodFound=false;
			String flagMethodName = "has"+featureName;
			
			try
			{
				
				//Loop through type and super types to find "has..." method indicates 
				//if a standard MTG attribute is set for this node
				while(!flagMethodFound)
				{
					int methodCount = currType.getDeclaredMethodCount();
					for(int j=0; j<methodCount; ++j)
					{
						Method method = currType.getDeclaredMethod(j);
						String methodName = method.getName();
						//if method found, invoke method to return flag that indicates if the
						//standard MTG attribute is set
						if(method.getName().equals(flagMethodName))
						{
							Object[] arg = new Object[0];
							hasThisStdAtt = ((Boolean)method.invoke(node, arg));
							flagMethodFound=true; //flag to end looping
						}
					}
					currType = currType.getSupertype();
					if(currType==null)
					{
						throw new MTGExportException("Unable to find flag indicator for standard MTG attribute.");
					}
				}
				return hasThisStdAtt;
			}
			catch(Throwable t)
			{
				throw new MTGExportException("Error obtaining attribute value.");
			}
		}
		else
			return false;
	}
	
	/**
	 * Adds features or attributes of node to list of features to be written in MTG header.
	 * @param node
	 * @throws MTGExportException 
	 */
	private void addFeatures(Node node) throws MTGExportException
	{		
		NType type = node.getNType();
		
		//get number of features in this node
		int c = type.getManagedFieldCount();
		
		for(int i =0; i<c ; ++i)
		{
			Field f = type.getManagedField(i);
			Type ft = f.getType();
			String featureType = ft.getName(); //e.g. double
			String featureName = f.getName();  //e.g. diameter
	
			String mtgType = MTGKeys.javaTypeToMTGType(featureType);
			//proceed only if java Type of feature can be represented in MTG data type
			if(mtgType!=null)
			{
				//check if feature already in list of features encountered so far.
				boolean alreadyListed=false;
				for(int j=0; j<this.fieldsGroIMP.size(); ++j)
				{
					if(fieldsGroIMP.get(j).equals(featureName))
					{
						alreadyListed=true;
						break;
					}
				}
				
				if(!alreadyListed)
				{
					//if field is a standard attribute, check if its value is set or used in this node
					boolean hasThisStdAtt=false;
					boolean isStdMTGAtt = MTGKeys.isStandardAttribute(featureName);
					if(isStdMTGAtt)
						hasThisStdAtt = isStandardAttributeSet(node,featureName);
				
					//only add to list of features to be exported if -
					// feature is standard mtg attribute and its value is set or used
					// OR feature is not standard mtg attribute
					if((isStdMTGAtt&&hasThisStdAtt) || (!isStdMTGAtt))
					{
						//to add list of features already encountered
						fieldsGroIMP.add(featureName);
						
						//add to features buffer for writing to MTG file header
						features.add(featureName + "\t" + mtgType);
					}
				}
			}
		}
	}

	/**
	 * Add a buffer line to ArrayList buffer 'mtg'.
	 * @param node
	 * @param edge
	 * @param nodeScale
	 * @param writeEdge
	 * @throws MTGExportException
	 */
	private void addBufferMtg(Node node, int edge, int nodeScale, boolean writeEdge) throws MTGExportException
	{
		//add class to list of mtg classes to be written in MTG header
		String nodeName = addClass(node.getNType().getSimpleName(),nodeScale);

		String bufferLine = "";

		//tabs for bifurcation
		for(int j=0; j<this.stack.size(); ++j)
			bufferLine+="\t";

		//symbol for continuing from mtg previous line
		if((edge!=Graph.BRANCH_EDGE)||((edge==Graph.BRANCH_EDGE)&&(!writeEdge)))
		{
			//if not the first node to be added
			if(latest.size()>0)
				bufferLine+="^";
		}

		//write edge type
		if(writeEdge)
		{
			String edgeSym = MTGKeys.edgeBitToSymbol(edge);
			if(edgeSym==null)
				throw new MTGExportException("Unrecognized edge type.");
			bufferLine+=edgeSym;
		}
		else
		{
			bufferLine+=MTGKeys.MTG_TOPO_KEYWORD_RELTYPE_REFI;
		}

		//write parent node class
		bufferLine+=nodeName;

		//write parent node id
		bufferLine+=Integer.toString(nextNodeId());
		
		//write feature values
		
		//number of tabs left to first feature value position
		int tabsLeft = (maxStackSize+1) - this.stack.size(); //maxStackSize+1 is the number of tabs between "ENTITY-CODE" and the first attribute name in the MTG body section
		for(int k=0; k<tabsLeft; ++k)
			bufferLine+="\t";
		
		//look for each feature in this node
		for(int f=0; f<this.fieldsGroIMP.size(); ++f)
		{
			String featureName = fieldsGroIMP.get(f);
			
			NType type = node.getNType();
			
			//get number of features in this node
			int c = type.getManagedFieldCount();
			
			//loop through list of fields in this node, find the feature with same name
			for(int i =0; i<c ; ++i)
			{
				Field field = type.getManagedField(i);
				Type fieldType = field.getType();
				String fieldTypeName = fieldType.getName(); //e.g. double
				String fieldName = field.getName();
				//if field corresponding to feature found in node
				if(fieldName.equals(featureName))
				{
					try
					{
						//if field is a standard attribute
						boolean hasThisStdAtt=false;
						boolean isStdMTGAtt = MTGKeys.isStandardAttribute(featureName);
						if(isStdMTGAtt)
							hasThisStdAtt = isStandardAttributeSet(node,featureName);

						//if this field is a std MTG attribute and flag indicates the value is set and used
						//OR this field is not a std MTG attribute,
						//write the value of the field
						if((isStdMTGAtt&&hasThisStdAtt) || (!isStdMTGAtt))
						{
							
								if(fieldTypeName.equals("int"))
								{
									bufferLine+=field.getInt(node);
								}
								if(fieldTypeName.equals("double"))
								{
									bufferLine+=field.getDouble(node);
								}
								if(fieldTypeName.equals("String"))
								{
									bufferLine+=(String)(field.getObject(node));
								}
						}
					}
					catch(Throwable t)
					{
						throw new MTGExportException("Error obtaining attribute value.");
					}
				}
			}
			
			bufferLine+="\t";
		}

		mtg.add(bufferLine);
	}

	/**
	 * For the input class, find the corresponding class name for export. If the class is encountered for the first time,
	 * add it to the list of encountered classes. 
	 * Calls method to create the content to be written into the MTG file.
	 * @param nodeClass
	 * @param nodeScale
	 * @return
	 * @throws MTGExportException
	 */
	private String addClass(String nodeClass, int nodeScale) throws MTGExportException
	{
		//check if node class has already been encountered
		int nodeClassIndex = hasEncounteredClass(nodeClass, nodeScale);
		String nodeSymbol = null;
		//if not encountered, add to classesGroIMP. assign corresponding class symbol in classesMTG
		//add to classes buffer
		if(nodeClassIndex==-1)
		{
			nodeSymbol = getMTGClassName(nodeClass);
			//this.classesGroIMP.add(nodeClass);
			//this.classesMTG.add(nodeSymbol);
			int classesCount = classesGroIMP.size();
			if(classesCount-1 < nodeScale)
			{
				for(int i=0; i< nodeScale-(classesCount-1) ; ++i)
				{
					classesGroIMP.add(new ArrayList<String>());
				}
			}

			//add to list of classes already encountered (sorted according to scale)
			classesGroIMP.get(nodeScale).add(nodeClass);

			//creates content to be written to MTG file
			addBufferClass(nodeSymbol,nodeScale);
		}
		else if(nodeClassIndex==-2)
		{
			throw new MTGExportException("Same module name in different scales. Error exporting.");
		}
		//if encountered, find corresponding class symbol in classesMTG
		else
		{
			if(nodeClassIndex >= classesGroIMP.get(nodeScale).size())
				throw new MTGExportException("No corresponding MTG class symbol for GroIMP module name");
			nodeSymbol = classesMTG.get(nodeScale).get(nodeClassIndex);
		}

		return nodeSymbol;
	}

	private void setLatestTrav(Node n, int nodeScale)
	{
		if(this.latest.size()-1 < nodeScale)
		{
			int originSize = latest.size();
			for(int i=0; i<(nodeScale-(originSize-1));++i)
			{
				latest.add(null);
			}
		}

		latest.set(nodeScale, n);
	}

	/**
	 * Input parameter node is the graph node traversed. Process the node class, features
	 * 
	 * @param edge
	 * @param node
	 * @throws MTGExportException 
	 */
	private void traverseNode(int edge, Node node, boolean attributeCount) throws MTGExportException
	{
		//process the node class
		//String nodeClass = node.getNType().getSimpleName();

		//add class to state variables and buffer
		//String assignedName = addClass(nodeClass,this.scale);

		//flag to indicate that edge type has been written
		boolean edgeWritten = false;

		//check parent hierarchy if traversal has made a traverse step in parent scales
		if(this.scale>1)
		{
			//for each parent scale, beginning from the coarsest scale
			for(int i=1; i<this.scale; ++i)
			{
				//find parent of this parent scale, i
				Node parentNode = node;
				//number of scales coarser than current node's scale to reach
				int numOfLevels = this.scale - i;
				while(numOfLevels>0)
				{
					for(Edge e = parentNode.getFirstEdge(); e!=null; e=e.getNext(parentNode))
					{
						if((e.getTarget()==parentNode)&&(e.testEdgeBits(Graph.REFINEMENT_EDGE)))
						{
							//move 1 scale to parent
							parentNode = e.getSource();
							numOfLevels--;
							break;
						}
					}
				}

				//compare found parent node with that in latest traversed node
				if(latest.size()-1 >= i)
				{
					Node lastTraversed = latest.get(i);

					//parent scale has also traversed to next node
					//write to buffer mtg parent node entry first
					if(lastTraversed!=parentNode)
					{
						if(!attributeCount)
							this.addBufferMtg(parentNode, edge, i, !edgeWritten);
						else
						{
							addFeatures(parentNode);
							if(stack.size()>maxStackSize)
								maxStackSize = stack.size();
						}
						setLatestTrav(parentNode,i);
						edgeWritten = true;
					}
				}
			}
		}
		if(!attributeCount)
			this.addBufferMtg(node, edge, this.scale, !edgeWritten);
		else
		{
			addFeatures(node);
			if(stack.size()>maxStackSize)
				maxStackSize = stack.size();
		}
		setLatestTrav(node,this.scale);
	}

	/**
	 * Check if a node class was already encountered and assigned a corresponding MTG class
	 * @param className
	 * @return index of GroIMP node class if already encountered. -1 otherwise.
	 */
	private int hasEncounteredClass(String className, int classScale)
	{
		if((classesGroIMP.size()-1) >= classScale) //search list only if scale in list exists
		{
			for(int i=0; i<classesGroIMP.size();++i) //i being the scale of the classes
			{
				for(int j=0; j<classesGroIMP.get(i).size(); ++j) //j being the index of a class in scale i
				{
					//if class already exists in the list
					if(classesGroIMP.get(i).get(j).equals(className)) 
					{
						if(	i == classScale)
							return j;
						else
							return -2; // return -2 if class name in list but in different scale
					}
				}
			}
		}
		return -1; //return -1 is class not in the list
	}

	/**
	 * Check if a node class was already encountered and assigned a corresponding MTG class
	 * @param className
	 * @return index of GroIMP node class if already encountered. -1 otherwise.
	 */
	private int hasAssignedClass(String className)
	{
		for(int i=0; i<classesMTG.size();++i)
		{
			if(classesMTG.get(i).equals(className))
			{
				return i;
			}
		}
		return -1;
	}
	
	/**
	 * Write buffers into the .mtg file
	 * @param out
	 * @throws IOException
	 */
	private void writeBuffers(OutputStream out) throws IOException
	{
		//create writer from outputstream
		OutputStreamWriter writer = new OutputStreamWriter(out);
		
		//write buffer code
		for(int i=0; i<code.size(); ++i)
		{
			writer.write(code.get(i) + "\n");
		}
		writer.write("\n");
		
		//write buffer classes
		for(int j=0; j<classes.size(); ++j)
		{
			ArrayList<String> classesScale = classes.get(j);
			for(int p=0; p<classesScale.size(); ++p)
				writer.write(classesScale.get(p) + "\n");
		}
		writer.write("\n");
		
		//write buffer description
		for(int k=0; k<description.size(); ++k)
		{
			writer.write(description.get(k) + "\n");
		}
		writer.write("\n");
		
		//write buffer features
		for(int m=0; m<features.size(); ++m)
		{
			writer.write(features.get(m) + "\n");
		}
		writer.write("\n");
		
		//write buffer mtg
		for(int n=0; n<mtg.size(); ++n)
		{
			writer.write(mtg.get(n) + "\n");
		}
		
		writer.close();
	}

	@Override
	public void write(File out) throws IOException {
		//get registry from source node
		//View3D v3d = (View3D) ((ObjectSource) source).getObject ();
		Registry r = workbench.getRegistry();

		//traverse the graph from the root node and fill the buffers
		try
		{
			fillBuffers(r);
		}
		catch(Throwable t)
		{
			t.printStackTrace();
		}

		//write buffers to outputstreamwriter
		try
		{
			FileOutputStream os = new FileOutputStream(out);
			writeBuffers(os);
			os.close();
		}
		catch(Throwable t)
		{

		}

	}

	@Override
	protected SceneTree createSceneTree(View3D scene) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void beginGroup(InnerNode group) throws IOException {
		// TODO Auto-generated method stub

	}

	@Override
	protected void endGroup(InnerNode group) throws IOException {
		// TODO Auto-generated method stub

	}

}
