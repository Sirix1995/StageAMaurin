<chapter id="c-statements">
<title>Blocks and Statements</title>

<para>
The sequence of execution of a programme is controlled by
<firstterm>statements</firstterm>, which are executed for their effect
and do not have values. The statements of the XL programming language
are a superset of the statements of the Java programming language. For
the general terms and specifications in the context of statements
and their execution,
see the Java language specification. Based on these definitions,
this chapter describes the
statements which are introduced by the XL programming language.
</para>
<para>
To simplify the formulations, the following convention is implicitly
present in the following, if not specified otherwise: If an execution
or evaluation which is part of a statement
<replaceable>s</replaceable> completes abruptly, then
<replaceable>s</replaceable> completes abruptly for the same reason,
and remaining substatements or subexpressions of
<replaceable>s</replaceable>, if any,
are not executed or evaluated.
</para>

<section><title>Expression Statements</title>

<para>
An <firstterm>expression statement</firstterm> is executed by
sequentially evaluating the expression; if this yields values,
these are discarded.
</para>
<productionset><title>Expression Statements</title>
<production id="ebnf.estmt">
  <lhs>ExpressionStatement</lhs>
  <rhs><nonterminal def="#ebnf.stexpr">StatementExpression</nonterminal> ';'
  </rhs>
</production>
<production id="ebnf.stexpr">
  <lhs>StatementExpression</lhs>
  <rhs><nonterminal def="#ebnf.cond">ConditionalExpression</nonterminal>
    [ <nonterminal def="#ebnf.aop">AssignmentOperator</nonterminal>
      <nonterminal def="#ebnf.assignment">AssignmentExpression</nonterminal> ]
  </rhs>
</production>
</productionset>

</section>


<section id="s-qpa"><title>Quasi-Parallel Assignment Statements</title>

<para>
The <firstterm>quasi-parallel assignment statements</firstterm>
are used to indirectly assign values to property variables
(<xref linkend="s-properties"/>) via a queue of assignment
requests.
</para>
<productionset><title>Quasi-Parallel Assignment Statements</title>
<production id="ebnf.qpa">
  <lhs>QuasiParallelAssignment</lhs>
  <rhs><nonterminal def="#ebnf.stexpr">StatementExpression</nonterminal>
    <nonterminal def="#ebnf.qpaop">QuasiParallelAssignmentOperator</nonterminal>
    <nonterminal def="#ebnf.expr">Expression</nonterminal> ';'
  </rhs>
</production>
<production id="ebnf.qpaop">
  <lhs>QuasiParallelAssignmentOperator</lhs>
  <rhs>':=' | ':+=' | ':-=' | ':*=' | ':/=' | ':&amp;=' | ':|=' | ':^='
  </rhs>
</production>
</productionset>
<para>
The left hand side of the assignment must be a property variable, or
a compile-time error occurs. The type of the right hand side
must be assignable to the type of the property variable, or a compile-time
error occurs. In addition, some operators have restrictions on the
types of their operands.
<itemizedlist>
<listitem><para>
 The operators <literal>:+=</literal>,
<literal>:-=</literal>, <literal>:*=</literal>,
and <literal>:/=</literal>, are only defined
for numeric types. A statement of the form
<replaceable>p</replaceable> <literal>:-=</literal>
<replaceable>e</replaceable><literal>;</literal> is treated as being the
statement <replaceable>p</replaceable> <literal>:+= -</literal><replaceable>e</replaceable><literal>;</literal>.
</para></listitem>
<listitem><para>
 The operators <literal>:&amp;=</literal>,
<literal>:|=</literal>, and <literal>:^=</literal>, are only defined
for integral types and <literal>boolean</literal>.
</para></listitem>
</itemizedlist>
</para>
<para>
The meaning of the quasi-parallel assignment operators is similar to
their normal counterparts without the colon prefix. Actually, this
should be ensured by the implementation of run-time models
(<xref linkend="s-rtmodel"/>), because the semantics of these
operators is implemented by run-time models. Namely, the execution
of a quasi-parallel assignment statement is done as follows:
</para>
<orderedlist>
<listitem><para>
The current extended state <replaceable>x</replaceable>
(<xref linkend="c-vmxstate"/>)
and the current queue collection <replaceable>c</replaceable>
(<xref linkend="s-currqc"/>) are determined.
</para></listitem>
<listitem><para>
The current <firstterm>property modification queue</firstterm>
<replaceable>q</replaceable> is determined by the method invocation
<replaceable>c</replaceable><literal>.getPropertyModificationQueue()</literal>.
If this returns <literal>null</literal>, a
<classname>NullPointerException</classname> is thrown.
</para></listitem>
<listitem><para>
The property variable of the left hand side is evaluated, i. e.,
the corresponding object <replaceable>o</replaceable> and the
run-time property <replaceable>p</replaceable> are determined
(<xref linkend="s-properties"/>, <xref linkend="s-bracketaccess"/>).
This includes that indices of component properties are pushed onto
<replaceable>x</replaceable>'s <literal>int</literal>-stack.
</para></listitem>
<listitem><para>
The right hand side is evaluated, resulting in a value
<replaceable>v</replaceable>.
</para></listitem>
<listitem><para>
The method <replaceable>q</replaceable>.<replaceable>m</replaceable><literal>(</literal><replaceable>o</replaceable>,
<replaceable>p</replaceable>, <replaceable>v</replaceable><literal>)</literal>
is invoked. Its name <replaceable>m</replaceable> is constructed
as follows: Let <replaceable>A</replaceable> be the type affix
(<xref linkend="s-typeaffix"/>) of the type of the property, then the
method name is
<itemizedlist>
<listitem><para>
<literal>set</literal><replaceable>A</replaceable> for the operator
<literal>:=</literal>,
</para></listitem>
<listitem><para>
<literal>add</literal><replaceable>A</replaceable> for the operator
<literal>:+=</literal>,
</para></listitem>
<listitem><para>
<literal>mul</literal><replaceable>A</replaceable> for the operator
<literal>:*=</literal>,
</para></listitem>
<listitem><para>
<literal>div</literal><replaceable>A</replaceable> for the operator
<literal>:/=</literal>,
</para></listitem>
<listitem><para>
<literal>and</literal><replaceable>A</replaceable> for the operator
<literal>:&amp;=</literal>,
</para></listitem>
<listitem><para>
<literal>or</literal><replaceable>A</replaceable> for the operator
<literal>:|=</literal>,
</para></listitem>
<listitem><para>
<literal>xor</literal><replaceable>A</replaceable> for the operator
<literal>:^=</literal>.
</para></listitem>
</itemizedlist>
</para></listitem>
</orderedlist>
<para>
Note that quasi-parallel assignments are statements, while normal
assignments are expressions.
</para>

</section>


<section><title>The <literal>assert</literal> Statement</title>

<para>
An <firstterm>assertion</firstterm> is a statement containing a
boolean expression. If the assertion is <firstterm>enabled</firstterm>
as specified by the Java Language Specification, Third Edition,
an evaluation of the assertion causes evaluation of the
boolean expression and an error is reported if the expression
evaluates to <literal>false</literal>. If an optional second expression
exists, the error message is based on the evaluation of this expression.
If the assertion is disabled, evaluation of the assertion has
no effect whatsoever.
</para>
<productionset><title>Assert Statement</title>
<production id="ebnf.assert">
  <lhs>AssertStatement</lhs>
  <rhs><literal>assert</literal>
    <nonterminal def="#ebnf.assnorange">AssignmentExpressionNoRange</nonterminal>
    [ ':' <nonterminal def="#ebnf.expr">Expression</nonterminal> ] ';'
  </rhs>
</production>
</productionset>
<para>
It is a compile-time error if the first expression does not have
type <classname>boolean</classname> or if the optional second expression
after the colon is <classname>void</classname>. The evaluation of an
<literal>assert</literal> is performed as specified by the
Java Language Specification, Third Edition.
</para>

</section>


<section><title>The Enhanced <literal>for</literal> Statement</title>


<para>
The enhanced <literal>for</literal> statement has the form
</para>
<productionset><title>Enhanced For Statement</title>
<production id="ebnf.enhfor">
  <lhs>EnhancedForStatement</lhs>
  <rhs><literal>for</literal> '(' <nonterminal def="#ebnf.iter">Iterator</nonterminal> ')'
    <nonterminal def="#ebnf.stat">Statement</nonterminal>
  </rhs>
</production>
<production id="ebnf.iter">
  <lhs>Iterator</lhs>
  <rhs>[ [ <nonterminal def="#ebnf.modifiers">Modifiers</nonterminal>
           <nonterminal def="#ebnf.type">Type</nonterminal> ]
         Identifier ':' ]
       <nonterminal def="#ebnf.stexpr">StatementExpression</nonterminal>
  </rhs>
</production>
</productionset>
<para>
It is used to iterate over <firstterm>finish iterators</firstterm>,
<firstterm>iterable objects</firstterm>,
arrays, or the sequentially yielded values
(<xref linkend="s-genexpr"/>) of the expression.
The distinction is based on the type
<replaceable>I</replaceable> of the expression, its
<firstterm>potential iteration type</firstterm>, and the specified type
and identifier, if any:
</para>
<itemizedlist>
<listitem><para>
If <replaceable>I</replaceable> is assignable to
<classname>de.grogra.xl.lang.FinishIterator</classname>,
the potential iteration is over a finish iterator, and
the potential iteration type is the return type of the
public member method named <methodname>value</methodname>
of <replaceable>I</replaceable> with no parameter,
or <literal>void</literal> if no such method exists.
</para></listitem>
<listitem><para>
Otherwise, if <replaceable>I</replaceable> has a public member method named
<methodname>iterator</methodname> with no parameter
and return type <classname>java.util.Iterator</classname>, the
potential iteration is over an iterable object, and the
potential iteration type is <classname>Object</classname>,
or the explicitly specified type if this is
a reference type.
</para></listitem>
<listitem><para>
Otherwise, if <replaceable>I</replaceable> is an array type,
the potential iteration is over an array, and
the potential iteration type is <replaceable>I</replaceable>'s component type.
</para></listitem>
<listitem><para>
Otherwise, the potential iteration is over the
sequentially yielded values of the expression, and the
potential iteration type is <replaceable>I</replaceable>.
</para></listitem>
</itemizedlist>
<para>
If no type has been specified explicitly in the
enhanced <literal>for</literal> statement, or if the potential
iteration type is assignable to the explicitly specified type,
then the actual iteration and type are the potential iteration and type,
otherwise the actual iteration is over the sequentially
yielded values of the expression, and the actual iteration type
is <replaceable>I</replaceable>.
</para>
<para>
If an identifier <replaceable>v</replaceable>
is specified in the enhanced <literal>for</literal>
statement, a local variable of that name is declared. Its scope
is the contained statement. It is a compile-time error if there
exists a local variable of the given name in the current scope.
The type <replaceable>T</replaceable> and modifiers
<replaceable>m</replaceable>
of the local variable are the given type and modifiers, or the actual
type and <literal>final</literal> if no type is specified.
It is a compile-time error if the
actual type is not assignable to the type of the variable.
</para>
<para>
Let <replaceable>e</replaceable> be the expression of the
enhanced <literal>for</literal> statement
and <replaceable>s</replaceable> the contained statement,
then the execution of the statement is as follows:
</para>
<itemizedlist>
<listitem><para>
An iteration over a finish iterator is equivalent to the following
statement.
<programlisting>
I #i = e;
Throwable #t = null;
try {
    while (#i.next()) {
        m T v = #i.value();
        s
    }
}
catch (Throwable #u) {
    #t = #u;
    throw #u;
}
finally {
    #i.finish(#t);
}
</programlisting>
If no local variable is declared by the enhanced
<literal>for</literal> statement, the line
<literal>m T v = #i.value();</literal> has to be removed.
</para></listitem>
<listitem><para>
An iteration over an iterable object is equivalent to the following
statement.
<programlisting>
for (java.util.Iterator #i = e.iterator(); #i.hasNext(); ) {
    m T v = (T) #i.next();
    s
}
</programlisting>
If no local variable is declared by the enhanced
<literal>for</literal> statement, the line
<literal>m T v = #i.next();</literal> has to be replaced by
<literal>#i.next();</literal>.
</para></listitem>
<listitem><para>
An iteration over an array is equivalent to the iteration
over the sequentially yielded values of its array generator
expression (<xref linkend="s-arraygen"/>).
</para></listitem>
<listitem><para>
An iteration over the sequentially yielded values
of <replaceable>e</replaceable> is executed by sequentially
evaluating the expression <literal>v = e</literal> and executing
<replaceable>s</replaceable> for every yielded result of
<literal>v = e</literal>.
If no local variable is declared by the enhanced
<literal>for</literal> statement, only the expression
<replaceable>e</replaceable> is evaluated sequentially.
</para></listitem>
</itemizedlist>
<para>
In the above definitions, the <literal>#</literal>-prefixed identifiers
are compiler-generated identifiers that are distinct from any other
identifier.
</para>

</section>


<section id="s-yield"><title>The <literal>yield</literal> Statement</title>

<para>
A <literal>yield</literal> statement yields a value as one of the results
of a generator method invocation (<xref linkend="s-gmethod-invocation"/>).
</para>
<productionset><title>Yield Statement</title>
<production id="ebnf.yield">
  <lhs>Yield</lhs>
  <rhs><literal>yield</literal> <nonterminal def="#ebnf.expr">Expression</nonterminal> ';'
  </rhs>
</production>
</productionset>
<para>
The type of the expression must be assignable to the declared return type
of the generator method declaration, or a compile-time error occurs.
The execution of a <literal>yield</literal> statement with
expression <replaceable>e</replaceable> is equivalent
to the sequential evaluation of the method invocation expression
<replaceable>c</replaceable><literal>.consume(</literal><replaceable>e</replaceable><literal>)</literal>,
where <replaceable>c</replaceable> is the implicit consumer parameter
of the generator method declaration (<xref linkend="s-generator-methods"/>)
and the results of the invocation are discarded.
</para>

</section>

</chapter>
