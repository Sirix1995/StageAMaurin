<chapter id="c-queries">
<title>Queries</title>

<para>
<firstterm>Queries</firstterm> are used in rules
and query expressions (<xref linkend="s-qexpr"/>) to specify
a pattern. At run-time, occurences of this pattern in the
current relational data source (to be more precise, in its
extent, <xref linkend="s-rtmodel"/>) are searched. The query
syntax provides versatile means for specifying patterns,
including a rich set of built-in predicates,
user-defined predicates, and transitive closures.
</para>
<para>
A query consists of a set of <firstterm>predicates</firstterm>
and <firstterm>query variables</firstterm>. The sequential
evaluation of a query <firstterm>binds</firstterm> values to
query variables in order to fulfil the conditions imposed
by the predicates. If a complete binding has been found which matches
all predicates, this <firstterm>match</firstterm> is yielded as one of
the results of the query. The current binding of query variables
is part of the <firstterm>query state</firstterm>.
</para>
<para>
In the sequel, the predicates of the XL programming language
are described. Each predicate is specified by the following properties:
</para>
<itemizedlist>
<listitem><para>
A predicate may have a set of parameters,
among them <firstterm>in-</firstterm> and
<firstterm>out-parameters</firstterm>. It has either no
in- and out-parameters, or it has both an in- and an
out-parameter. Parameters of predicates have a compile-time type.
The in-parameter may coincide with the
out-parameter, in this case the parameter is called the
predicate's <firstterm>in-out-parameter</firstterm>.
In- and out-parameters are used when neighbouring predicates
of a <firstterm>connected predicate</firstterm> are to be connected.
</para></listitem>
<listitem><para>
In- and out-parameters are either <firstterm>open</firstterm>
or <firstterm>closed</firstterm>. This information is used
for connecting predicates, too.
</para></listitem>
<listitem><para>
A predicate is <firstterm>fulfilled</firstterm>, given a binding
for its query variables, only if a specific condition is fulfilled.
</para></listitem>
</itemizedlist>

<section id="s-queryvar"><title>Query Variables</title>

<para>
<firstterm>Query variables</firstterm> are a special kind of local
variables. They are implicitly <literal>final</literal> in the sense of
the Java programming language. It is illegal to assign values
to query variables, even in their declaration.
Instead of this, values are <firstterm>bound</firstterm>
to query variables as part of the sequential evaluation of a query;
this evaluation is performed by the run-time system of the XL
programming language.
</para>
<para>
Query variables are declared explicitly by
compound predicates and some other predicates, or implicitly
by a compiler for the XL programming language where this is needed.
The identifiers of the latter have to be generated
such that they are distinct from any other
identifier.
</para>
<para>
An explicitly declared query variable <replaceable>v</replaceable>
is a <firstterm>label</firstterm>
for a <firstterm>place</firstterm> (<xref linkend="s-places"/>).
If the place is a node place
and a wrapper is needed for the type of <replaceable>v</replaceable>
(<xref linkend="s-ctmodel"/>) in order to represent its values
as nodes, <replaceable>v</replaceable> is <firstterm>wrapped</firstterm>
by another query variable which is called the <replaceable>v</replaceable>'s
<firstterm>wrapper variable</firstterm> (<xref linkend="s-places"/>).
The identifier
of the wrapper variable is the identifier of <replaceable>v</replaceable>
with the single character <literal>$</literal> prepended.
</para>
<para>
Query variables are
represented by instances of <classname>VMXState.Local</classname>, i.e.,
their values are stored on the stack of the extended state
of the virtual machine (<xref linkend="c-vmxstate"/>). Otherwise,
the run-time system of the XL programming language would not be able
to bind values to these variables.
</para>

</section>

<section id="s-query-invocation"><title>Invocation of Queries</title>

<para>
A query expression (<xref linkend="s-qexpr"/>) is evaluated sequentially by
<firstterm>invocation</firstterm> of the query. This is done as follows:
</para>
<orderedlist>
<listitem><para>
A compiler for the XL programming language has to produce code
which encodes the structure of the query
in an instance <replaceable>q</replaceable> of
<classname>de.grogra.xl.qnp.Query</classname>. For every type
<replaceable>T</replaceable> which is primitive or
<classname>Object</classname>, the class
<classname>Query</classname> declares a generator method
(<xref linkend="s-generator-methods"/>) named
<methodname>find</methodname><replaceable>A</replaceable><methodname>Matches</methodname>
with return type <replaceable>T</replaceable> and a single parameter
of type <classname>de.grogra.xl.runtime.Model</classname>.
<replaceable>A</replaceable> is the type affix of <replaceable>T</replaceable>
(<xref linkend="s-typeaffix"/>).
</para></listitem>
<listitem><para>
At run-time, the invocation of the query is done by a generator
method invocation (<xref linkend="s-gmethod-invocation"/>) of the
suitable generator method on <replaceable>q</replaceable>.
The single argument to the method is the current run-time model
(<xref linkend="s-rtmodel"/>) that corresponds to the
compile-time model of the query. This sequentially yields the values
of the query.
</para></listitem>
<listitem><para>
The implementation of the generator methods in
<classname>Query</classname> at first obtains an
instance <replaceable>qs</replaceable>
of <classname>de.grogra.xl.qnp.QueryState</classname> by
the invocation of the method <methodname>createQueryState</methodname>
on the current extent (<xref linkend="s-currextent"/>) with
the current extended state of the virtual machine
(<xref linkend="c-vmxstate"/>) as argument. Then <replaceable>qs</replaceable>
is set up to represent the <firstterm>query state</firstterm> of the
query. For example, the current binding of query variables is accessible
through the query state.
</para></listitem>
<listitem><para>
Finally, after all values have been yielded, the method invocation
<replaceable>qs</replaceable><methodname>.getExtent().dispose</methodname>(<replaceable>qs</replaceable>)
is performed.
</para></listitem>
</orderedlist>

</section>


<section><title>Compound Predicates</title>

<para>
Technically, a query consists of a single
<firstterm>compound predicate</firstterm>. A compound predicate
starts with an optional declaration of query variables. Its main part
is a <firstterm>predicate list</firstterm>, which defines
the properties of the compound predicate.
</para>
<productionset><title>Queries and Compound Predicates</title>
<production id="ebnf.query">
  <lhs>Query</lhs>
  <rhs><nonterminal def="#ebnf.compound">CompoundPredicate</nonterminal></rhs>
</production>
<production id="ebnf.compound">
  <lhs>CompoundPredicate</lhs>
  <rhs>{ <nonterminal def="#ebnf.vardeclnoinit">VariableDeclarationNoInitializer</nonterminal> ';' }
    <nonterminal def="#ebnf.predlist">PredicateList</nonterminal>
  </rhs>
</production>
<production id="ebnf.predlist">
  <lhs>PredicateList</lhs>
  <rhs><nonterminal def="#ebnf.connected">ConnectedPredicate</nonterminal>
    { ',' <nonterminal def="#ebnf.connected">ConnectedPredicate</nonterminal> }
  </rhs>
</production>
<production id="ebnf.context">
  <lhs>ContextPredicate</lhs>
  <rhs>'(*' <nonterminal def="#ebnf.predlist">PredicateList</nonterminal> '*)'
  </rhs>
</production>
<production id="ebnf.branchpred">
  <lhs>BranchPredicate</lhs>
  <rhs>'[' <nonterminal def="#ebnf.predlist">PredicateList</nonterminal> ']'
  </rhs>
</production>
<production id="ebnf.connected">
  <lhs>ConnectedPredicate</lhs>
  <rhs><nonterminal def="#ebnf.condpred">ConditionPredicate</nonterminal>
    | <nonterminal def="#ebnf.primpred">PrimaryPredicate</nonterminal>
    { <nonterminal def="#ebnf.primpred">PrimaryPredicate</nonterminal> }
  </rhs>
</production>
<production id="ebnf.condpred">
  <lhs>ConditionPredicate</lhs>
  <rhs>'(' <nonterminal def="#ebnf.expr">Expression</nonterminal> ')'
  </rhs>
</production>
<production id="ebnf.primpred">
  <lhs>PrimaryPredicate</lhs>
  <rhs><nonterminal def="#ebnf.context">ContextPredicate</nonterminal>
    | <nonterminal def="#ebnf.branchpred">BranchPredicate</nonterminal>
    | <nonterminal def="#ebnf.simplepred">SimplePredicate</nonterminal>
  </rhs>
</production>
</productionset>
<para>
The in-parameter of a predicate list is the in-parameter of its
first connected predicate which has an in-parameter,
or the predicate list has no
in-parameter if no such connected predicate exists.
The out-parameter of the predicate list is the out-parameter of its last
connected predicate which has an out-parameter,
or the predicate list has no
out-parameter if no such connected predicate exists.
</para>
<para>
A predicate list is fulfilled if and only if all of its contained connected
predicates are fulfilled.
</para>
<para>
Context predicates and branch predicates inherit their in- and
out-parameters from the contained predicate list. They are fulfilled
if and only if the contained predicate list is fulfilled.
</para>

<section id="s-places">

<title>Places</title>

<para>
A <firstterm>place</firstterm> denotes a set of
predicate parameters which are <firstterm>associated</firstterm> with
each other. A place also has a set of associated query variables.
One of these query variables may be the
<firstterm>label</firstterm> of the place.
One of these query variables is the <firstterm>main variable</firstterm>
of the place. Places may be <firstterm>node places</firstterm>,
main variables of node places are bound to nodes of the
current extent (<xref linkend="c-datamodel"/>).
</para>
<para>
Initially, a place is created for each predicate parameter, and the
parameter is associated with this place. Later on, places my be
merged, resulting in a single place which contains
all associations of the merged places. Places are merged in two cases:
</para>
<orderedlist>
<listitem><para>
If two places have the same label variable, they are merged.
</para></listitem>
<listitem><para>
A predicate list may merge places of neighbouring
primary predicates (<xref linkend="s-connecting"/>).
</para></listitem>
</orderedlist>
<para>
Like a predicate, a place imposes conditions on its query variables
which have to be fulfilled for the place to match for a binding
of the variables.
</para>
<para>
The main variable is determined as follows:
</para>
<itemizedlist>
<listitem><para>
If the place is a node place and has a label variable
<replaceable>q</replaceable>
whose values have to be wrapped in order to be represented as
nodes (<xref linkend="s-ctmodel"/>), then an additional query variable
is declared and associated with the place.
It wraps the values of <replaceable>q</replaceable>.
Its identifier is the identifier of <replaceable>q</replaceable>
with the single character <literal>$</literal> prepended.
Its <firstterm>preliminary type</firstterm>
is determined by the invocation of the method
<methodname>getWrapperClassFor</methodname> of the current
compile-time model (<xref linkend="s-ctmodel"/>) with the type
of <replaceable>q</replaceable> as argument. The wrapper variable
is the main variable of the place. For a binding
of the query variables, the bound value of
<replaceable>q</replaceable> must be equal to
the result of the invocation of the method
<methodname>unwrap</methodname><replaceable>A</replaceable> on the
current run-time model (<xref linkend="s-rtmodel"/>) with
the bound value of the wrapper variable as argument.
<replaceable>A</replaceable> is the type affix
(<xref linkend="s-typeaffix"/>) of the type of <replaceable>q</replaceable>.
</para></listitem>
<listitem><para>
Otherwise, if the place is a node place without label variable,
and if there are
associated predicate parameters whose values are not representable
as nodes, an unnamed variable is declared implicitly, its type
being the type of the first parameter (in order of association) which needs
a wrapper. Now one proceeds as before, with <replaceable>q</replaceable>
being replaced by the implicitly declared variable.
</para></listitem>
<listitem><para>
Otherwise, if the place is a node place,
the main variable is declared implicitly, its preliminary
type being <classname>Object</classname>.
</para></listitem>
<listitem><para>
Otherwise, the place is not a node place.
If the place has a label, the main variable is the label variable.
If the place has no label, the main variable is declared implicitly,
its preliminary type being the type of the first parameter
(in order of association).
</para></listitem>
</itemizedlist>
<para>
For each associated predicate parameter, there is a
query variable of suitable type. Depending on the type of the
predicate parameters, a single query variable is sufficient for all
parameters, or the compiler has to provide several distinct,
implicitly declared query variables. The query variable for
the parameters are determined as follows:
</para>
<itemizedlist>
<listitem><para>
If there exist parameters of numeric type,
let <replaceable>N</replaceable> be the first (in order of
association) of these types.
If the place is a node place, it follows from the previous statements
that there is a wrapper variable which wraps a query variable
<replaceable>s</replaceable>. Otherwise, if the place is not a node place,
let <replaceable>s</replaceable> be the main variable.
If <replaceable>s</replaceable> does not have a numeric type,
a compile-time error occurs. Now for each parameter having a numeric
type <replaceable>T</replaceable>, its query variable is determined:
<itemizedlist>
<listitem><para>
If <replaceable>T</replaceable> and the type of
some query variable <replaceable>v</replaceable> of the place
are assignable to <classname>int</classname>,
or if there exists a query variable <replaceable>v</replaceable>
having type <replaceable>T</replaceable>,
the query variable for the parameter is <replaceable>v</replaceable>.
</para></listitem>
<listitem><para>
Otherwise, an implicit query variable <replaceable>t</replaceable>
is declared in the place,
its type being <replaceable>T</replaceable>. This variable is the
query variable for the parameter. For a binding
of the query variables, the bound value of
<replaceable>t</replaceable>, converted to the type
of <replaceable>s</replaceable> by a casting conversion,
has to be equal to the bound value of <replaceable>s</replaceable>
in order for the place to match.
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para>
For each of the remaining parameters of non-numeric type
<replaceable>T</replaceable>:
<itemizedlist>
<listitem><para>
If the place has a wrapper variable and values of type
<replaceable>T</replaceable> have to be wrapped,
the preliminary type of the wrapper variable is replaced
by the intersection (<xref linkend="s-intersection"/>)
of the preliminary type and
the type returned by the invocation of the method
<methodname>getWrapperClassFor</methodname> of the current
compile-time model (<xref linkend="s-ctmodel"/>) with
<replaceable>T</replaceable> as argument.
The preliminary type of the wrapped variable is replaced
by the intersection of the preliminary type and
<replaceable>T</replaceable>. The wrapped variable is the query
variable for the parameter.
</para></listitem>
<listitem><para>
Otherwise, if the place has a wrapper variable, but values of type
<replaceable>T</replaceable> need not be wrapped, or if the place
is not a node place,
the preliminary type of the main variable is replaced
by the intersection of the preliminary type and
<replaceable>T</replaceable>. The main variable is the query
variable for the parameter.
</para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
<para>
Afterwards, the actual types of query variables
are set to their preliminary types.
</para>
<para>
When we speak of the bound value of a predicate parameter in the
context of a binding of query variables, the bound value
of the query variable associated with this predicate parameter is
to be understood.
</para>

</section>

<section><title>Connected Predicates</title>

<para>
A connected predicate is either a single
<firstterm>condition predicate</firstterm>, or a list of
<firstterm>primary predicates</firstterm>. If it is a condition predicate,
it has no in- and out-parameters, and it is fulfilled
if and only if the contained
expression evaluates to <literal>true</literal>. It is a compile-time
error if the type of this expression is not <literal>boolean</literal>.
</para>
<para>
If the connected predicate consists of a list of primary predicates,
its in-parameter is the in-parameter of the first primary predicate
which has an in-parameter and which is not a context predicate
or a branch predicate, or it has no in-parameter if no such predicate
exists. The same holds for the out-parameter, with the role of the first
primary predicate replaced by the last primary predicate.
A list of primary predicates is fulfilled if and only if all of its
primary predicates are fulfilled.
</para>
<para>
A list of primary predicates also defines the
<firstterm>node places</firstterm>: A place is a node place if and only
if an in- or out-parameter of a primary predicate of a list
is associated with the place.
</para>

</section>

<section id="s-connecting"><title>Connecting Primary Predicates</title>

<para>
A list of primary predicates is connected by a pairwise connection
of neighbouring primary predicates. The primary predicates of
an ordered pair (<replaceable>L</replaceable>, <replaceable>R</replaceable>)
are neighbouring if <replaceable>L</replaceable> is not a branch predicate and
<replaceable>L</replaceable> textually precedes <replaceable>R</replaceable>
with at most branch predicates inbetween. For every
ordered pair (<replaceable>L</replaceable>, <replaceable>R</replaceable>)
of neighbouring primary predicates,
the connection is established as follows:
</para>
<itemizedlist>
<listitem><para>
If <replaceable>L</replaceable> has a closed out-parameter and
<replaceable>R</replaceable> has a closed in-parameter,
an implicit standard edge predicate
(<xref linkend="s-stdedgepred"/>) is inserted.
If <replaceable>R</replaceable>
is a branch predicate, the standard edge is a forward branch edge, otherwise
it is a forward successor edge.
The in-parameter of the edge predicate is associated
with the place of <replaceable>L</replaceable>'s out-parameter,
the out-parameter of the edge predicate is associated with the
place of <replaceable>R</replaceable>'s in-parameter.
</para></listitem>
<listitem><para>
Otherwise, if <replaceable>L</replaceable> has an out-parameter and
<replaceable>R</replaceable> has an in-parameter, their places
are merged to a single place.
</para></listitem>
<listitem><para>
Otherwise, if <replaceable>L</replaceable> has an open out-parameter and
<replaceable>R</replaceable> has no in-parameter,
or if <replaceable>L</replaceable> has no out-parameter and
<replaceable>R</replaceable> has an open in-parameter,
a compile-time error occurs.
</para></listitem>
<listitem><para>
Otherwise, <replaceable>L</replaceable> and <replaceable>R</replaceable>
are not connected.
</para></listitem>
</itemizedlist>

</section>

</section>

<section><title>Simple Predicates</title>

<productionset><title>Simple Predicates</title>
<production id="ebnf.simplepred">
  <lhs>SimplePredicate</lhs>
  <rhs>Identifer ':' '.'
    | Identifier ':' <nonterminal def="#ebnf.spnl">SimplePredicateNoLabel</nonterminal>
    | <nonterminal def="#ebnf.spnl">SimplePredicateNoLabel</nonterminal>
  </rhs>
</production>
<production id="ebnf.spnl">
  <lhs>SimplePredicateNoLabel</lhs>
  <rhs><nonterminal def="#ebnf.namepred">NamePredicate</nonterminal>
    | <nonterminal def="#ebnf.parampred">ParametrizedPredicate</nonterminal>
    | <nonterminal def="#ebnf.tpred">TypePredicate</nonterminal>
    | <nonterminal def="#ebnf.wtpred">WrappedTypePredicate</nonterminal>
    | <nonterminal def="#ebnf.exprpred">ExpressionPredicate</nonterminal>
    | <nonterminal def="#ebnf.methodpred">MethodPredicate</nonterminal>
    | <nonterminal def="#ebnf.rootpred">RootPredicate</nonterminal>
    | <nonterminal def="#ebnf.pathpred">PathPredicate</nonterminal>
    | <nonterminal def="#ebnf.stdedgepred">StandardEdgePredicate</nonterminal>
    | <nonterminal def="#ebnf.firstpred">FirstElementPredicate</nonterminal>
    | <nonterminal def="#ebnf.closure">TransitiveClosure</nonterminal>
    | <nonterminal def="#ebnf.minimal">MinimalElementsPredicate</nonterminal>
  </rhs>
</production>
</productionset>
<para>
The simplest form of a simple predicate is an identifier,
followed by a colon, followed by a dot:
<programlisting>
x:.
</programlisting>
This predicate declares
a query variable with the given identifier as name as its
label. The type of the query variable is the node type of the
current compile-time model (<xref linkend="s-ctmodel"/>), i.e., the
result of the invocation of the method <methodname>getNodeClass</methodname>
on this model. The predicate has a single closed in-out-parameter of the
same type. The predicate is fulfilled if and only if
the value of the parameter is a node of the current run-time model
(<xref linkend="s-rtmodel"/>), i.e., if
the invocation of the method <methodname>isNode</methodname> on
this model with the value of the in-out-parameter as argument returns
<literal>true</literal>.
</para>
<para>
The other simple predicates may be prefixed by a label, i.e.,
an identifier, followed by a colon. If the labelled predicate has
a closed in-out-parameter, a query variable is declared, its type being
the type of the in-out-parameter, its name being the identifier.
Otherwise, a compile-time error occurs. Here are some examples for
labelled predicates:
<programlisting>
x:Object
a:F(b)
</programlisting>
</para>


<section id="s-predarg"><title>Predicate Arguments</title>

<productionset><title>Predicate Arguments</title>
<production id="ebnf.predarg">
  <lhs>PredicateArgument</lhs>
  <rhs>Identifier | <nonterminal def="#ebnf.assignment">AssignmentExpression</nonterminal>
  </rhs>
</production>
</productionset>
<para>
Some of the following predicates make use of
<firstterm>predicate arguments</firstterm>. Predicate arguments
are related to predicate parameters in a similar way as arguments
of method invocation expressions are related to method parameters.
However, there is an important difference:
</para>
<itemizedlist>
<listitem><para>
If the predicate argument is a single identifier, and a local
variable of that name has not yet been declared in the current scope,
the predicate argument is a label argument
(<xref linkend="s-labelarg"/>) with the given identifier. Note that
this declares a query variable with the identifier as its name.
</para></listitem>
<listitem><para>
Otherwise, if the predicate argument is a single identifier
and a query variable of that name exists in the current query,
then it is used as label variable for the place of the corresponding
predicate parameter.
</para></listitem>
<listitem><para>
Otherwise, the predicate argument is handled as an expression. A
condition is imposed on the query variable corresponding to
the predicate parameter: Its value has to be equal in the sense
of the operator <literal>==</literal> to the result of the evaluation
of the expression.
</para></listitem>
</itemizedlist>
<para>
Note that fields cannot be addressed by a single identifier
in predicate arguments: Single identifiers as predicate arguments
are always interpreted as local variables. If such a variable does
not yet exist, it is declared. In order to use a field
for a predicate argument expression, it can be enclosed in
parentheses, or it can be qualified as in the following example:
</para>
<programlisting>
int f;                // field declaration

void test() [
    X(f) ::> {}       // attention: implicit declaration of query variable f
    X((f)) ::> {}     // field access expression for f is used
    X(this.f) ::> {}  // field access expression for f is used
]
</programlisting>

</section>


<section id="s-labelarg"><title>Label Arguments</title>

<para>
Some of the following predicates may have
<firstterm>label arguments</firstterm> as their
predicate arguments (<xref linkend="s-predarg"/>). A label
argument is defined by a single identifier. A query variable
is declared whose name is this identifier, this variable is then used
as the label of the place of the corresponding
predicate parameter.
</para>

</section>


<section id="s-namepred"><title>Name Predicates</title>

<productionset><title>Name Predicates</title>
<production id="ebnf.namepred">
  <lhs>NamePredicate</lhs>
  <rhs><nonterminal def="#ebnf.name">Name</nonterminal>
  </rhs>
</production>
</productionset>
<para>
A name predicate consists of a single name and may denote a local
variable, a field, a type, a predicate, or a method. The meaning
is resolved as follows:
</para>
<itemizedlist>
<listitem><para>
If the name is a single identifier, and if a local
variable <replaceable>v</replaceable> of that name exists in the
current scope, this is handled specially: If <replaceable>v</replaceable> is
a query variable of the current query, then the name predicate is
a type predicate (<xref linkend="s-typepred"/>) of the type of
<replaceable>v</replaceable>, and <replaceable>v</replaceable>
is made the label variable of the type predicate. This kind of
a name predicate is used to refer to previously defined places.
Otherwise, the name predicate is an expression predicate
(<xref linkend="s-exprpred"/>). Its expression
is the variable <replaceable>w</replaceable>
if <replaceable>v</replaceable> has a wrapper variable
<replaceable>w</replaceable>, otherwise it is <replaceable>v</replaceable>
itself.
</para></listitem>
<listitem><para>
Otherwise, the meaning of the name is
determined as described in <xref linkend="s-meaning"/>, where the possible
meanings are expression names, type names, predicate names, or method names.
An expression name is reclassified as an expression predicate
(<xref linkend="s-exprpred"/>), a type name as
a type predicate (<xref linkend="s-typepred"/>), a predicate
name as a class predicate (<xref linkend="s-classpred"/>) with
no arguments, and a method name as a method predicate
(<xref linkend="s-methodpred"/>) with no arguments.
</para></listitem>
</itemizedlist>

</section>


<section id="s-parampred"><title>Parametrized Predicates</title>

<productionset><title>Parametrized Predicates</title>
<production id="ebnf.parampred">
  <lhs>ParametrizedPredicate</lhs>
  <rhs><nonterminal def="#ebnf.name">Name</nonterminal>
   '(' [ <nonterminal def="#ebnf.oparg">OptPredicateArgument</nonterminal>
   { ',' <nonterminal def="#ebnf.oparg">OptPredicateArgument</nonterminal> } ] ')'
  </rhs>
</production>
<production id="ebnf.oparg">
  <lhs>OptPredicateArgument</lhs>
  <rhs><nonterminal def="#ebnf.predarg">PredicateArgument</nonterminal>
    | '.'
    |
  </rhs>
</production>
</productionset>
<para>
A parametrized predicate is specified by a name and a number of arguments.
Each argument may by a predicate argument (<xref linkend="s-predarg"/>),
or it may be <firstterm>empty</firstterm>, which is represented by
a single dot or even by omitting it at all (the latter is possibly only
if there are at least two arguments, i.e., at least one comma).
An empty argument is handled as a label argument
(<xref linkend="s-labelarg"/>) with an internal, compiler-generated identifier.
Examples for parametrized predicates are:
</para>
<programlisting>
F(x)
M(.)
X(a,,,d,)
Object(x)
root(n)
</programlisting>
<para>
The meaning of the name is
determined as described in <xref linkend="s-meaning"/>, where the possible
meanings are predicate names,
type names if there exists exactly one argument,
and method names if there are no empty arguments.
If the name is a predicate name, the parametrized predicate
is reclassified as a class predicate (<xref linkend="s-classpred"/>)
with the specified arguments.
If the name is a type name, the parametrized predicate
is reclassified as a wrapped type predicate (<xref linkend="s-wtypepred"/>)
with the specified argument.
If the name is a method name, the parametrized predicate
is reclassified as a method predicate (<xref linkend="s-methodpred"/>)
with the specified arguments.
</para>

</section>


<section id="s-typepred"><title>Type Predicates</title>

<productionset><title>Type Predicates</title>
<production id="ebnf.tpred">
  <lhs>TypePredicate</lhs>
  <rhs><nonterminal def="#ebnf.type">Type</nonterminal>
  </rhs>
</production>
</productionset>
<para>
A type predicate is specified by a single type.
A type predicate may also result from the reclassification of a name predicate
(<xref linkend="s-namepred"/>).
Examples are:
<programlisting>
Object
Runnable
long
String[]
javax.swing.tree.TreeNode
</programlisting>
A type predicate has a single closed in-out-parameter of the specified type.
It is fulfilled for every binding of values to query variables; it just serves
to restrict the type of its associated query variable.
</para>

</section>


<section id="s-wtypepred"><title>Wrapped Type Predicates</title>

<productionset><title>Type Predicates</title>
<production id="ebnf.wtpred">
  <lhs>WrappedTypePredicate</lhs>
  <rhs><nonterminal def="#ebnf.type">Type</nonterminal>
    '(' <nonterminal def="#ebnf.predarg">PredicateArgument</nonterminal> ')'
  </rhs>
</production>
</productionset>
<para>
Wrapped type predicates are used to identify
<firstterm>wrapper nodes</firstterm> which wrap values of
other (non-node-) types. A wrapped type predicate is specified by a single type
<replaceable>T</replaceable> and
an argument enclosed in parentheses.
A wrapped type predicate may also result from the reclassification of a
parametrized predicate (<xref linkend="s-parampred"/>).
Examples are:
<programlisting>
String[](a)
int(i)
</programlisting>
A wrapped type predicate has two parameters: The first is its
closed in-out-parameter, its type is the result of the method invocation
<methodname>getWrapperClassFor(</methodname><replaceable>T</replaceable><methodname>)</methodname> on the
current compile-time model (<xref linkend="s-ctmodel"/>).
The second parameter has type <replaceable>T</replaceable>.
A wrapped type predicate is fulfilled if and only if the result of
the invocation of the method
<methodname>isWrapperFor(</methodname><replaceable>o</replaceable>,
<replaceable>T</replaceable><methodname>)</methodname>
on the current run-time model (<xref linkend="s-rtmodel"/>) returns
<literal>true</literal>, where <replaceable>o</replaceable>
is the bound value of the first parameter, and if in addition the
result of the invocation of the method
<methodname>unwrap</methodname><replaceable>A</replaceable><methodname>(</methodname><replaceable>o</replaceable><methodname>)</methodname>
on the current run-time model
is equal in the sense of the operator <literal>==</literal>
to the bound value of the second parameter.
<replaceable>A</replaceable> is the type affix (<xref linkend="s-typeaffix"/>)
of <replaceable>T</replaceable>.
</para>

</section>


<section id="s-exprpred"><title>Expression Predicates</title>

<productionset><title>Expression Predicates</title>
<production id="ebnf.exprpred">
  <lhs>ExpressionPredicate</lhs>
  <rhs><nonterminal def="#ebnf.primnop">PrimaryNoParen</nonterminal>
  | '\(' <nonterminal def="#ebnf.expr">Expression</nonterminal> ')'
  </rhs>
</production>
</productionset>
<para>
Expression predicates are used to directly fix the value of a
query variable to the result of an expression. If necessary,
the expression has to be enclosed in backslash-prefixed parentheses;
the backslash is needed in order to disambiguate the syntax.
An expression predicate may also result from the reclassification of a
name predicate (<xref linkend="s-namepred"/>),
a method predicate (<xref linkend="s-methodpred"/>),
or a root predicate (<xref linkend="s-rootpred"/>).
Examples are:
<programlisting>
this
"Hello World"
42
\(a[i])
\(x + y)
</programlisting>
An expression predicate has a single closed in-out-parameter of the
type of the expression. It is fulfilled iff the bound value of the
parameter is equal in the sense of the operator <literal>==</literal>
to the result of the evaluation of the expression.
</para>

</section>

<section id="s-methodpred"><title>Method Predicates</title>

<productionset><title>Method Predicates</title>
<production id="ebnf.methodpred">
  <lhs>MethodPredicate</lhs>
  <rhs><nonterminal def="#ebnf.primnop">PrimaryNoParen</nonterminal>
  { '.' Identifier <nonterminal def="#ebnf.args">Arguments</nonterminal> }
  '.' Identifier <nonterminal def="#ebnf.args">Arguments</nonterminal>
  </rhs>
</production>
</productionset>
<para>
Method predicates are used to create predicates from methods. At first,
the tokens to the left from the last '.' are
treated as an ordinary expression. Then the most specific
applicable (<xref linkend="c-signatures"/>) and accessible method
declared in or inherited by the type of the expression is chosen,
where the set of possible argument transformations
(<xref linkend="s-argtrans"/>) is:
<itemizedlist>
<listitem><para>
All argument transformations of method invocation expressions
(<xref linkend="s-mi-argtrans"/>). In this case, the whole
method predicate is treated as an expression and is thus reclassified
as an expression predicate (<xref linkend="s-exprpred"/>).
</para></listitem>
<listitem><para>
An additional argument transformation is defined for methods
with return type <classname>boolean</classname>. This
transformation provides
a single implicit argument which is prepended before the explicit
argument expressions and is commensurate with the first method parameter.
In this case, the method predicate has a single closed in-out-parameter
of the type of the first method parameter. The method predicate
is fulfilled iff the invocation of the method returns
<literal>true</literal> for a binding of the single parameter.
</para></listitem>
</itemizedlist>
Method predicates may also
result from the reclassification of a
name predicate (<xref linkend="s-namepred"/>) or a
parametrized predicate (<xref linkend="s-parampred"/>), in these cases
they consist of a name and an argument list. The name is resolved
as for method invocation expressions, and the predicate is handled
as before.
</para>
<para>
Examples for method predicates are:
<programlisting>
getRoot()
x.getParent()
isVisible()
</programlisting>
</para>

</section>


<section id="s-classpred"><title>Class Predicates</title>

<para>
A class predicate results from the reclassification of a
name predicate (<xref linkend="s-namepred"/>) or a
parametrized predicate (<xref linkend="s-parampred"/>). The
reclassification provides a predicate name and a
list of arguments for the class predicate. Now the most specific
class predicate (<xref linkend="c-predicates"/>) is determined
as specified for signatures (<xref linkend="c-signatures"/>),
and the parameters of the resulting class predicate declaration
are the parameters of the predicate.
The following alternatives of argument transformations
(<xref linkend="s-argtrans"/>) are possible:
</para>
<itemizedlist>
<listitem><para>
The arguments are not transformed at all. The invocation uses the
explicitly specified argument expressions. In this case,
the predicate has no in- and out-parameters.
</para></listitem>
<listitem><para>
For class predicate declarations whose first parameter is
the in-out-parameter (<xref linkend="c-predicates"/>), an
additional argument transformation exists. It provides
a single implicit argument which is prepended before the explicit
argument expressions and is commensurate with the in-out-parameter.
In this case, the in-out-parameter of the declaration is the
closed in-out-parameter of the predicate.
</para></listitem>
</itemizedlist>
<para>
Label arguments (<xref linkend="s-labelarg"/>)
are always commensurate with their parameter.
Note that for class predicates, parameters and arguments of reference type
are commensurate if there exists a casting conversion
(<xref linkend="s-applicability"/>).
</para>
<para>
As a class predicate is declared by a subclass of
<classname>de.grogra.xl.qnp.ClassPredicate</classname>
(<xref linkend="c-predicates"/>), its class has to implement the
abstract method <methodname>createMatcher</methodname>. The returned
instance of <classname>de.grogra.xl.qnp.Predicate.Matcher</classname>
defines a means to fulfill the class predicate.
</para>

</section>


<section id="s-rootpred"><title>Root Predicate</title>

<productionset><title>Root Predicate</title>
<production id="ebnf.rootpred">
  <lhs>RootPredicate</lhs>
  <rhs>'^'
  </rhs>
</production>
</productionset>
<para>
A root predicate is used to bind a query variable to the root node
of the extent (<xref linkend="s-rtmodel"/>) of the current query state
<replaceable>qs</replaceable> (<xref linkend="s-query-invocation"/>).
It is reclassified as an expression predicate
(<xref linkend="s-exprpred"/>), its expression being
<replaceable>qs</replaceable><literal>.getExtent().getRoot()</literal>.
</para>

</section>

</section>

<section id="s-pathpred"><title>Path Predicates</title>

<productionset><title>Path Predicates</title>
<production id="ebnf.pathpred">
  <lhs>PathPredicate</lhs>
  <rhs>'-' <nonterminal def="#ebnf.pathspec">PathSpecification</nonterminal> '-'
  | '-' <nonterminal def="#ebnf.pathspec">PathSpecification</nonterminal> '->'
  | '&lt;-' <nonterminal def="#ebnf.pathspec">PathSpecification</nonterminal> '-'
  </rhs>
</production>
<production id="ebnf.pathspec">
  <lhs>PathSpecification</lhs>
  <rhs><nonterminal def="#ebnf.namepathpred">NamePathPredicate</nonterminal>
  | <nonterminal def="#ebnf.parampathpred">ParametrizedPathPredicate</nonterminal>
  | <nonterminal def="#ebnf.methodpathpred">MethodPathPredicate</nonterminal>
  | <nonterminal def="#ebnf.expredgepred">ExpressionEdgePredicate</nonterminal>
  </rhs>
</production>
</productionset>
<para>
Path predicates are used to connect their neighbouring predicates by
a binary relation. In order to do this,
they have both an open in-parameter and an open out-parameter, these
are merged with the in- and out-parameters of their neighbouring
predicates (<xref linkend="s-connecting"/>).
</para>
<para>
A path predicate is specified by its <firstterm>direction</firstterm>
and a path specification. The direction is indicated by the
tokens around the path specification:
For <literal>- -</literal>, it is <firstterm>undirected</firstterm>,
for <literal>- -></literal>, it is <firstterm>forward</firstterm>,
for <literal>&lt;- -</literal>, it is <firstterm>backward</firstterm>.
If the direction is backward, the in- and out-parameters of the
contained path specification are swapped.
</para>


<section id="s-namepathpred"><title>Name Path Predicates</title>

<productionset><title>Name Path Predicates</title>
<production id="ebnf.namepathpred">
  <lhs>NamePathPredicate</lhs>
  <rhs><nonterminal def="#ebnf.name">Name</nonterminal>
  </rhs>
</production>
</productionset>
<para>

</para>

</section>


<section id="s-parampathpred"><title>Parametrized Path Predicates</title>

<productionset><title>Parametrized Path Predicates</title>
<production id="ebnf.parampathpred">
  <lhs>ParametrizedPathPredicate</lhs>
  <rhs><nonterminal def="#ebnf.name">Name</nonterminal>
  <nonterminal def="#ebnf.args">Arguments</nonterminal>
  </rhs>
</production>
</productionset>
<para>

</para>

</section>


<section id="s-methodpathpred"><title>Method Path Predicates</title>

<productionset><title>Method Path Predicates</title>
<production id="ebnf.methodpathpred">
  <lhs>MethodPathPredicate</lhs>
  <rhs><nonterminal def="#ebnf.selexpr">SelectorExpression</nonterminal>
  '.' Identifier <nonterminal def="#ebnf.args">Arguments</nonterminal>
  </rhs>
</production>
</productionset>
<para>

</para>

</section>


<section id="s-expredgepred"><title>Expression Edge Predicates</title>

<productionset><title>Expression Edge Predicates</title>
<production id="ebnf.expredgepred">
  <lhs>ExpressionEdgePredicate</lhs>
  <rhs><nonterminal def="#ebnf.selexpr">SelectorExpression</nonterminal>
  </rhs>
</production>
</productionset>
<para>
An expression edge predicate contains a single expression. It allows
to specify an edge pattern which consists of a single value. At first,
the expression is converted by method invocation conversion
to the type <replaceable>E</replaceable> returned by
<replaceable>m</replaceable>.<methodname>getEdgeClassFor</methodname>(<replaceable>T</replaceable>),
where <replaceable>m</replaceable> is the current compile-time model
(<xref linkend="s-ctmodel"/>) and <replaceable>T</replaceable> the
original type of the expression. If such a conversion does not exist,
a compile-time error occurs.
</para>
<para>
If the resulting expression is a compile-time constant,
and if its type <replaceable>E</replaceable> is primitive or has
<classname>java.io.Serializable</classname> as superinterface,
then the expression edge predicate is reclassified as
a constant edge predicate (<xref linkend="s-constedgepred"/>) having
the constant value of the expression as its value.
</para>

</section>


<section id="s-stdedgepred"><title>Standard Edge Predicates</title>

<productionset><title>Standard Edge Predicates</title>
<production id="ebnf.stdedgepred">
  <lhs>StandardEdgePredicate</lhs>
  <rhs>'>' | '&lt;' | '+>' | '&lt;+' | '-->' | '&lt;--' | '--'
  </rhs>
</production>
</productionset>
<para>
Standard edge predicates provide simple means to specify a
connectivity relation between their neighbouring predicates. They are
shorthands for constant edge predicates (<xref linkend="s-constedgepred"/>).
The translation is defined by the following table:
</para>
<table frame="all"><title>Reclassification as constant edge predicate</title>
<tgroup cols="3" align="left" colsep='1' rowsep='1'>
<thead>
<row>
  <entry>Predicate token</entry>
  <entry>Constant <replaceable>X</replaceable></entry>
  <entry>Direction</entry>
</row>
</thead>
<tbody>
<row>
  <entry><literal>></literal></entry>
  <entry><literal>SUCCESSOR_EDGE</literal></entry>
  <entry>forward</entry>
</row>
<row>
  <entry><literal>&lt;</literal></entry>
  <entry><literal>SUCCESSOR_EDGE</literal></entry>
  <entry>backward</entry>
</row>
<row>
  <entry><literal>+></literal></entry>
  <entry><literal>BRANCH_EDGE</literal></entry>
  <entry>forward</entry>
</row>
<row>
  <entry><literal>&lt;+</literal></entry>
  <entry><literal>BRANCH_EDGE</literal></entry>
  <entry>backward</entry>
</row>
<row>
  <entry><literal>--></literal></entry>
  <entry><literal>ANY_EDGE</literal></entry>
  <entry>forward</entry>
</row>
<row>
  <entry><literal>&lt;--</literal></entry>
  <entry><literal>ANY_EDGE</literal></entry>
  <entry>backward</entry>
</row>
<row>
  <entry><literal>--</literal></entry>
  <entry><literal>ANY_EDGE</literal></entry>
  <entry>undirected</entry>
</row>
</tbody>
</tgroup>
</table>
<para>
The constant of the reclassified constant edge predicate is obtained by
<replaceable>m</replaceable>.<methodname>getStandardEdgeFor</methodname>(<classname>de.grogra.xl.qnp.EdgePredicate</classname>.<replaceable>X</replaceable>),
where <replaceable>m</replaceable> is the current compile-time model
(<xref linkend="s-ctmodel"/>).  The returned value has to be an instance of
the type returned by
<replaceable>m</replaceable>.<methodname>getStandardEdgeClass()</methodname>
or an instance of the boxing type if the returned type is primitive.
In the latter case, unboxing conversion is applied to the constant
before reclassification.
</para>

</section>


<section id="s-constedgepred"><title>Constant Edge Predicates</title>

<para>
A constant edge predicate results from the reclassification of
an expression edge predicate (<xref linkend="s-expredgepred"/>)
or a standard edge predicate (<xref linkend="s-stdedgepred"/>).
</para>

</section>

</section>


<section><title>Control Flow Predicates</title>

<para>
Control flow predicates are constructed from other predicates.
Unlike the other predicates, they govern the control flow of pattern
matching.
</para>

<section><title>First Element Predicate</title>

<productionset><title>First Element Predicate</title>
<production id="ebnf.firstpred">
  <lhs>FirstElementPredicate</lhs>
  <rhs>'(' <nonterminal def="#ebnf.compound">CompoundPredicate</nonterminal> ')' '!'
  </rhs>
</production>
</productionset>
<para>
</para>

</section>

<section><title>Transitive Closures</title>

<productionset><title>Transitive Closures</title>
<production id="ebnf.closure">
  <lhs>TransitiveClosure</lhs>
  <rhs>'(' <nonterminal def="#ebnf.compound">CompoundPredicate</nonterminal> ')'
    <nonterminal def="#ebnf.quantifier">Quantifier</nonterminal> 
  </rhs>
</production>
<production id="ebnf.quantifier">
  <lhs>Quantifier</lhs>
  <rhs>'?' | '*' | '+' | <nonterminal def="#ebnf.rangequantifier">RangeQuantifier</nonterminal> 
  </rhs>
</production>
<production id="ebnf.rangequantifier">
  <lhs>RangeQuantifier</lhs>
  <rhs>'{' <nonterminal def="#ebnf.assignment">AssignmentExpression</nonterminal>
    [ ',' <nonterminal def="#ebnf.assignment">AssignmentExpression</nonterminal> ] '}'
  </rhs>
</production>
</productionset>
<para>
</para>

</section>


<section><title>Minimal Elements Predicate</title>

<productionset><title>Minimal Elements Predicate</title>
<production id="ebnf.minimal">
  <lhs>MinimalElementsPredicate</lhs>
  <rhs><nonterminal def="#ebnf.closure">TransitiveClosure</nonterminal>
    ':' '(' <nonterminal def="#ebnf.compound">CompoundPredicate</nonterminal> ')'
  </rhs>
</production>
</productionset>
<para>
</para>

</section>

</section>

</chapter>
