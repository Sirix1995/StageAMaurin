#if (!$generate)
	#set ($generate = true)
	#foreach ($i in ["F", "M", "RV"])
		#foreach ($j in ["0", "", "Add", "Mul"])
			#set ($k = "$i$j")
			#set ($out = "de/grogra/turtle/${k}.java")
			$generator.parse("de/grogra/turtle/CommandModules.vm", $out)
		#end
	#end
	#set ($i = "M")
	#set ($j = "Rel")
	#set ($k = "MRel")
	#set ($out = "de/grogra/turtle/${k}.java")
	$generator.parse("de/grogra/turtle/CommandModules.vm", $out)
#else

$pp.autogenerated

/*
 * Copyright (C) 2002 - 2007 Lehrstuhl Grafische Systeme, BTU Cottbus
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package de.grogra.turtle;

import de.grogra.graph.*;

#set ($tc = false)
#set ($length = false)
#set ($rvarg = false)
#set ($length = false)


#if (($k == "F") || ($k == "M"))
	#set ($length = true)
#end


/**
 * The turtle command
#if ($j == "0")
 * <code>$k</code>
#else
 * <code>$k(x)</code>
#end
#if ($i == "RV")
 * represents a rotation which implements gravitropism. Its strength is
#if ($k == "RV")
 * given by the specified {@link #argument}.
#else
 * the <code>localTropism</code>
#end
#else
#if ($i == "F")
 * represents a cylinder along the local z-direction.
 * In addition, this command translates the local coordinate system
 * along the axis of the cylinder such that the origin of the
 * children's coordinate system coincides with the center of the cylinder's top.
 * <br>
 * The diameter of the cylinder
#if ($k == "F")
 * is {@link #diameter}, if this value
 * is non-negative, otherwise it
#end
 * is taken from the field
 * <code>localDiameter</code> of the current {@link de.grogra.turtle.TurtleState}.
 * The shader of the cylinder
#if ($k == "F")
 * is defined by the {@link #color}, if this value
 * is non-negative, otherwise it
#end
 * is taken from the the current {@link de.grogra.turtle.TurtleState}.
 * The length of the axis is
#else
 * represents a movement along the local z-direction. The length of the movement is
#end
#if ($length)
 * defined by {@link #length}.
#else
#if ($i == "F")
 * the <code>localLength</code>
#else
 * the <code>length</code>
#end
#end
#end
#if ($j != "")
 * of the current {@link de.grogra.turtle.TurtleState}
#if ($j == "Add")
 * incremented by the specified {@link #argument argument}.
#elseif ($j == "Mul")
 * multiplied by the specified {@link #argument argument}.
#elseif ($k == "MRel")
 * multiplied by the specified {@link #argument argument}
 * minus one.
#end
#end
 * <br>
#if ($i == "M")
#set ($gg = "f")
#else
#set ($gg = "$i")
#end
#if ($j.endsWith("Add"))
#set ($gg = "${gg}+")
#elseif ($j.endsWith("Mul"))
#set ($gg = "${gg}*")
#end
#if ($k == "MRel")
#set ($gg = "@(x)")
#elseif ($j != "0")
#set ($gg = "${gg}(x)")
#end
 * This corresponds to the turtle command <code>$gg</code>
 * of the GROGRA software.
 *
 * @author Ole Kniemeyer
 */
public class $k extends
#if (($k == "F") || ($k == "F0"))
	Shoot
#elseif ($i == "F")
	ArgShoot
#elseif (($k == "M") || ($k == "M0"))
	TurtleStep
	#set ($tc = true)
#elseif ($i == "M")
	Move
#elseif ($i == "RV")
	GRotation
	#set ($tc = true)
#end

#if ($tc)
	implements TurtleModifier
#end
{

#if ($length)
	#set ($length = true)

	public float length;
	//enh:field attr=Attributes.LENGTH
#end

#if ($k == "F")
	public float diameter = -1;
	//enh:field
	public int color = -1;
	//enh:field
#end

#if (($i == "RV") && ($k != "RV0"))
	#set ($rvarg = true)

	public float argument;
	//enh:field attr=Attributes.ARGUMENT
#end

	private static void initType ()
	{
#if ($tc)
		$TYPE.addIdentityAccessor (Attributes.TURTLE_MODIFIER);
#end
#if ($i == "RV")
		$TYPE.addDependency (TurtleStateAttribute.ATTRIBUTE, Attributes.TRANSFORMATION);
#end
#if ($length)
		$TYPE.addDependency (Attributes.LENGTH, Attributes.TURTLE_MODIFIER);
#elseif ($rvarg)
		$TYPE.addDependency (Attributes.ARGUMENT, Attributes.TURTLE_MODIFIER);
#elseif (($k == "M0") || ($k == "F0"))
		$TYPE.addDependency (TurtleStateAttribute.ATTRIBUTE, Attributes.LENGTH);
#end
	}

	//enh:insert initType ();

#if ($j != "0")

	public static class Pattern extends de.grogra.xl.impl.base.FieldListPattern
	{
		public Pattern ()
		{
			super (${k}.$TYPE,
#if ($length)
				   length$FIELD
#else
				   argument$FIELD
#end
			);
		}

		public static void signature (@In @Out ${k} n, float a)
		{
		}
	}


	public $k ()
	{
		this (1);
	}

#if ($length)

	public $k (float argument)
	{
		super ();
		length = argument;
	}

#elseif ($rvarg)

	public $k (float argument)
	{
		super ();
		this.argument = argument;
	}

	private float getArgument (Object node, GraphState gs)
	{
		if (node == this)
		{
			if (gs.getInstancingPathIndex () <= 0)
			{
				return argument;
			}
			else
			{
				return gs.checkFloat (this, true, Attributes.ARGUMENT, argument);
			}
		}
		else
		{
			return gs.getFloat (node, true, Attributes.ARGUMENT);
		}
	}

#else

	public $k (float argument)
	{
		super (argument);
	}

#end

#end

#if ($k == "F")

	public F (float length, float diameter, int color)
	{
		this (length);
		this.diameter = diameter;
		this.color = color;
	}


	public F (float length, float diameter)
	{
		this (length);
		this.diameter = diameter;
	}


	@Override
	protected float getFloat (FloatAttribute a, GraphState gs)
	{
		return ((a == Attributes.RADIUS) && (diameter >= 0))
			? 0.5f * diameter : super.getFloat (a, gs);
	}


	@Override
	protected int getInt (IntAttribute a, GraphState gs)
	{
		return ((a == Attributes.DTG_COLOR) && (color >= 0))
			? color : super.getInt (a, gs);
	}

#end

#if ($i != "RV")
	@Override
	public float getLength (Object node, GraphState gs)
	{
#if ($length)
		if (node == this)
		{
			if (gs.getInstancingPathIndex () <= 0)
			{
				return length;
			}
			else
			{
				return (float) gs.checkDouble (this, true, Attributes.LENGTH, length);
			}
		}
		else
		{
			return (float) gs.getDouble (node, true, Attributes.LENGTH);
		}
#else

		TurtleState state = TurtleState.getBefore (node, gs);
#if ($k == "F0")
		return state.localLength;
#elseif ($k == "FAdd")
		return state.localLength + getArgument (node, gs);
#elseif ($k == "FMul")
		return state.localLength * getArgument (node, gs);
#elseif ($k == "M0")
		return state.length;
#elseif ($k == "MAdd")
		return state.length + getArgument (node, gs);
#elseif ($k == "MMul")
		return state.length * getArgument (node, gs);
#elseif ($k == "MRel")
		return state.length * (getArgument (node, gs) - 1);
#end

#end
	}

#else


	@Override
	public float getTropismStrength (Object node, GraphState gs)
	{
#if ($k != "RV")
		TurtleState state = TurtleState.getBefore (node, gs);
#end
#if ($k == "RV")
		return getArgument (node, gs);
#elseif ($k == "RV0")
		return state.localTropism;
#elseif ($k == "RVAdd")
		return state.localTropism + getArgument (node, gs);
#elseif ($k == "RVMul")
		return state.localTropism * getArgument (node, gs);
#end
	}
#end

#if ($i != "F")
	public void execute (Object node, TurtleState state, GraphState gs)
	{
#if ($k == "RV")
		state.localTropism = state.tropism;
#elseif ($k == "RV0")
		state.localTropism = state.tropism;
#elseif ($k == "RVAdd")
		state.localTropism = state.tropism;
#elseif ($k == "RVMul")
		state.localTropism = state.tropism;
#elseif ($k == "M")
		state.relPosition -= getLength (node, gs) / state.length;
#elseif ($k == "M0")
		state.relPosition -= 1;
#elseif ($k == "MAdd")	
		state.relPosition -= (state.length + getArgument (node, gs)) / state.length;
#elseif ($k == "MMul")
		state.relPosition -= getArgument (node, gs);
#elseif ($k == "MRel")
		state.relPosition = 1 - getArgument (node, gs);
#end
	}
#end

}
#end
