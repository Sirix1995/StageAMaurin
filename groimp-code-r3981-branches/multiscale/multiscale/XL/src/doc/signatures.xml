<chapter id="c-signatures">
<title>Signatures</title>

<para>
The Java programming language defines the <firstterm>signature</firstterm>
of a method. The XL programming language introduces
class predicates (<xref linkend="c-predicates"/>) which also have a
signature. This chapter defines the common terms and operations
on signatures: Argument transformations, applicability, and specificity.
They are used in the context of a <firstterm>signature invocation</firstterm>,
which is either a method invocation (<xref linkend="s-method-invocation"/>)
or the usage of a class predicate in a query
(<xref linkend="s-classpred"/>). A signature invocation provides
a set of explicit argument expressions.
</para>

<section id="s-argtrans"><title>Argument Transformations</title>

<para>
Some syntactic contexts provide an
<firstterm>argument transformation</firstterm>
for signature invocations or even a set of
<firstterm>alternatives</firstterm> of argument transformations.
Such transformations alter the explicit argument expressions to
the actual argument expressions. This may contain, e.g., the addition
of <firstterm>implicit arguments</firstterm>.
The alternatives of argument transformations have an effect on the
applicability of signatures.
</para>

</section>

<section id="s-applicability"><title>Applicable Signatures</title>

<para>
The applicability of signature declarations to invocations
is defined as follows. The invocation context specifies
a set of alternatives of argument transformations. For each
transformation, check these steps:
</para>
<orderedlist>
<listitem><para>
The argument transformation computes the actual argument expressions
using the explicit argument expressions.
How this is performed is specified by the argument transformation.
</para></listitem>
<listitem><para>
If the number of parameters in the signature declaration does not equal
the number of actual argument expressions, then the
signature is not applicable for this alternative of argument transformations.
</para></listitem>
<listitem><para>
Otherwise, if the type of each actual argument is
<firstterm>commensurate</firstterm> with the corresponding parameter,
then the signature is applicable for this alternative.
Unless specified otherwise by the argument transformation,
the following rules define if an argument of an invocation is
commensurate with a parameter:
<itemizedlist>
<listitem><para>
If the signature is a class predicate and argument and parameter
are of reference type, the argument is commensurate with the parameter
iff a casting conversion from the argument type
to the parameter type exists.
</para></listitem>
<listitem><para>
Otherwise, the argument is commensurate with the parameter
iff a method invocation conversion from the argument type
to the parameter type exists.
</para></listitem>
</itemizedlist>
</para></listitem>
</orderedlist>

</section>

<section><title>Specificity of Signatures</title>

<para>
If more than one signature declaration is both accessible and applicable to
a signature invocation, it is necessary to choose one. The XL
programming language follows the Java programming language and chooses
the <firstterm>most specific signature</firstterm>. This term is defined
in the Java Language Specification for method signatures
and based on a pairwise comparison of method declarations: Let
<replaceable>m</replaceable> and <replaceable>n</replaceable> be two
signature declarations, then <replaceable>m</replaceable> is
<firstterm>less specific</firstterm>
than <replaceable>n</replaceable> with respect to the arguments
of the invocation if and only if one of the following is true:
</para>
<itemizedlist>
<listitem><para>
<replaceable>m</replaceable> has less parameters than
<replaceable>n</replaceable>.
</para></listitem>
<listitem><para>
The signatures are equal and 
<replaceable>m</replaceable> is not more specific than
<replaceable>n</replaceable> according to the Java language
specification.
</para></listitem>
<listitem><para>
<replaceable>n</replaceable> is more specific
than <replaceable>m</replaceable> with respect to
the arguments, and
<replaceable>m</replaceable> is not more specific
than <replaceable>n</replaceable> with respect to
the arguments. A signature is more specific
than another with respect to arguments if all of the following is true:
<itemizedlist>
<listitem><para>
For every parameter, it is true that
there exists a method invocation conversion
to the type of the corresponding parameter of the other signature,
or that it has a primitive type and the other parameter has a reference type.
</para></listitem>
<listitem><para>
The number of widening
<classname>double</classname>-to-<classname>float</classname>
conversions (see <xref linkend="s-widening"/>) from the arguments
to the signature parameters is less than this number for
the other signature, or if these numbers are equal, the number of
widening primitive conversions to <classname>double</classname>
from the arguments to the signature
parameters is less than or equal to this number for the other signature.
</para></listitem>
</itemizedlist>
</para></listitem>
</itemizedlist>
<para>
Now a signature is more specific than another in the sense of the Java
programming language if it is not less specific than the other. The
determination of the most specific signature proceeds as defined in the
Java Language Specification for methods.
</para>

</section>

</chapter>
