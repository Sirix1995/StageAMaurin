/*
 * Copyright (C) 2002 - 2007 Lehrstuhl Grafische Systeme, BTU Cottbus
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package de.grogra.imp3d.glsl;

import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBufferFloat;
import java.awt.image.PixelInterleavedSampleModel;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.nio.FloatBuffer;
import java.util.logging.Logger;

import javax.media.opengl.DebugGL;
import javax.media.opengl.GL;
import javax.media.opengl.GLAutoDrawable;
import javax.media.opengl.GLCapabilities;
import javax.media.opengl.GLContext;
import javax.media.opengl.GLDrawableFactory;
import javax.media.opengl.GLEventListener;
import javax.media.opengl.GLPbuffer;
import javax.vecmath.Matrix4d;
import javax.vecmath.Tuple3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;

import com.sun.opengl.util.ImageUtil;

import de.grogra.graph.ArrayPath;
import de.grogra.graph.GraphUtils;
import de.grogra.graph.Path;
import de.grogra.graph.impl.GraphManager;
import de.grogra.imp.View;
import de.grogra.imp.edit.ViewSelection;
import de.grogra.imp3d.Camera;
import de.grogra.imp3d.PolygonArray;
import de.grogra.imp3d.Polygonizable;
import de.grogra.imp3d.Polygonization;
import de.grogra.imp3d.PolygonizationCache;
import de.grogra.imp3d.View3D;
import de.grogra.imp3d.glsl.light.LightCollection;
import de.grogra.imp3d.glsl.light.shadow.ShadowLightCollection;
import de.grogra.imp3d.glsl.material.MaterialCollection;
import de.grogra.imp3d.glsl.material.channel.FloatToFloatCollection;
import de.grogra.imp3d.glsl.material.channel.GLSLChannelMap;
import de.grogra.imp3d.glsl.material.channel.Transform3DCollection;
import de.grogra.imp3d.glsl.renderpass.FullQualityRenderPass;
import de.grogra.imp3d.glsl.renderpass.RenderPass;
import de.grogra.imp3d.glsl.utility.GLSLManagedShader;
import de.grogra.imp3d.objects.Attributes;
import de.grogra.imp3d.objects.Sky;
import de.grogra.imp3d.shading.Light;
import de.grogra.imp3d.shading.Shader;
import de.grogra.pf.boot.Main;
import de.grogra.util.Debug;
import de.grogra.util.EnumerationType;
import de.grogra.util.EventListener;
import de.grogra.util.I18NBundle;
import de.grogra.util.WrapException;
import de.grogra.xl.lang.ObjectConsumer;

/**
 * Extension to the GLDisplay class to work with shaders generated by ShaderOGL
 * 
 * @author Konni Hartmann, nmi
 */
public class GLSLDisplay extends GLDisplay {

	/**
	 * Debug switch. May be used to test if debug output should be printed.
	 * This variable is set to true by specifying the argument 
	 * "-Dgroimp.debug.GLSLDisplay=1" for the Java VM.
	 */
	public static final boolean DEBUG = Debug.debug("GLSLDisplay");

	/**
	 * Output a string to OUT if the DEBUG switch is set. This version
	 * terminates the line. 
	 * @param string The String to be printed.
	 */
	public static void printDebugInfoN(String string) {
		if (DEBUG)
			System.out.println(string);
	}

	/**
	 * Output a string to OUT if the DEBUG switch is set. This version
	 * does not terminate the line. 
	 * @param string The String to be printed.
	 */
	public static void printDebugInfo(String string) {
		if (DEBUG)
			System.out.print(string);
	}

	private static int TONEMAPPING_MAX = 1;

	private static final I18NBundle I18N = I18NBundle
			.getInstance(GLSLDisplay.class);

	/**
	 * Enumeration of the available Tonemapping-Algorithms. This is used by the 
	 * configuration Dialog of OpenGL (Proteus). 
	 */
	public static final EnumerationType TONEMAPPING_TYPE = new EnumerationType(
			"tonemapping", I18N, TONEMAPPING_MAX + 1);

	private static final String OPTION_NAME_TONEMAPPING = "tonemapping";
	private int tonemapping = 0;
	
	private static final String OPTION_NAME_BRIGHTNESS = "brightness";
	private float brightness = 1.0f;
	private static final String OPTION_NAME_AUTOADJUSTBRIGHTNESS = "autoAdjustBrightness";
	private boolean optionAutoAdjustBrightness = true;

	private static final String OPTION_NAME_EDGEFILTERING = "edgeFiltering";
	private boolean optionEdgeFiltering = false;

	private static final String OPTION_NAME_SHADERANTIALIASING = "shaderAntialiasing";
	private boolean optionShaderAntialiasing = false;

	private static final String OPTION_NAME_ALTDRAWING = "altDrawing";
	private boolean optionAltDrawing = false;

	private static final String OPTION_NAME_PHYSICALLIGHTING = "physicalLighting";
	private boolean optionPhysicalLighting = false;

	private static final String OPTION_NAME_DIFFUSESKYLIGHT = "diffuseSkyLight";
	private boolean optionShowDiffuseSkyLight = false;

	private static final String OPTION_NAME_SHOWSKY = "showSky";
	private boolean optionShowSky = true;

	private static final String OPTION_NAME_SHOWSHADOWS = "showShadows";
	private boolean optionShowShadows = true;

	private static final String OPTION_NAME_MAXDEPTH = "maxDepth";
	private int optionMaxDepth = 4;

	private static final String OPTION_NAME_DEBUGRENDERPASS = "debugRenderPass";
	private int optionDebugRenderPass = 0;

	private static final String OPTION_NAME_BACKGROUND_COLOR_R = "backgroundColorR";
	private float optionBackgroundColorR = 1;
	
	private static final String OPTION_NAME_BACKGROUND_COLOR_G = "backgroundColorG";
	private float optionBackgroundColorG = 1;
	
	private static final String OPTION_NAME_BACKGROUND_COLOR_B = "backgroundColorB";
	private float optionBackgroundColorB = 1;

	private static final String OPTION_NAME_BACKGROUND_ALPHA = "backgroundAlpha";
	private float optionBackgroundAlpha = 1;
	
	//use background image
	private static final String OPTION_NAME_SHOW_BACKGROUND_IMAGE = "showBGImage";
	protected boolean optionShowBGImage = true;

	static boolean checked = false;
	static boolean ok = false;

	static int DEPTH_STENCIL_SETUP;
	
	static
	{
		class MyEventListener implements GLEventListener {
			public MyEventListener(JOGL_Test test) {
				this.test = test;
			}
			
			private JOGL_Test test;
			
			public int getDepthStencilSetup() {
				return test.getDepthStencilSetup();
			}
			
			final Logger logger = Main.getLogger ();
			
			public void reshape(GLAutoDrawable arg0, int arg1, int arg2, int arg3,
					int arg4) {}			

			public void init(GLAutoDrawable arg0) {
				GL gl = arg0.getGL();
				test.GLTest(gl, logger);
			}

			public void displayChanged(GLAutoDrawable arg0, boolean arg1, boolean arg2) {}

			public void display(GLAutoDrawable arg0) {}
		}
				
		GLCapabilities glcaps = new GLCapabilities();
		GLPbuffer pbuf = GLDrawableFactory.getFactory().createGLPbuffer(glcaps,null,1,1,null);
		
		MyEventListener EVTListener = new MyEventListener(new JOGL_Test());
		pbuf.addGLEventListener(EVTListener);
		
		pbuf.display();
		pbuf.destroy();
		
		DEPTH_STENCIL_SETUP = EVTListener.getDepthStencilSetup();
		
		switch (DEPTH_STENCIL_SETUP) {
		case JOGL_Test.DSS_COMBINED:
			fqrp = new FullQualityRenderPass();
			break;
		case JOGL_Test.DSS_SEPERATE:
		case JOGL_Test.DSS_DEPTH_ONLY:
		default:
			fqrp = new de.grogra.imp3d.glsl.renderpass.nostencil.FullQualityRenderPass();
		}
		
		if (DEPTH_STENCIL_SETUP != JOGL_Test.DSS_COMBINED)
		{
			Main.getLogger().warning("GPU not supported by OpenGL (Proteus)");
			throw new RuntimeException("GPU not supported by OpenGL (Proteus)");
		}
	}

	@Override
	public void initView(View view, EventListener listener) {
		super.initView(view, listener);

		optionShowSky = (Boolean) getOption(OPTION_NAME_SHOWSKY, true);
		optionShowShadows = (Boolean) getOption(OPTION_NAME_SHOWSHADOWS, true);
		optionAutoAdjustBrightness = (Boolean) getOption(OPTION_NAME_AUTOADJUSTBRIGHTNESS, true);
		optionEdgeFiltering = (Boolean) getOption(OPTION_NAME_EDGEFILTERING,false);
		optionShaderAntialiasing = (Boolean) getOption(OPTION_NAME_SHADERANTIALIASING, false);
		optionAltDrawing = (Boolean) getOption(OPTION_NAME_ALTDRAWING, false);
		brightness = (Float) getOption(OPTION_NAME_BRIGHTNESS, 1.0f);
		tonemapping = (Integer) getOption(OPTION_NAME_TONEMAPPING, 0);
		optionPhysicalLighting = (Boolean) getOption(OPTION_NAME_PHYSICALLIGHTING, false);
		optionShowDiffuseSkyLight = (Boolean) getOption(OPTION_NAME_DIFFUSESKYLIGHT, false);
		optionMaxDepth = (Integer) getOption(OPTION_NAME_MAXDEPTH, 4);
		optionDebugRenderPass = (Integer) getOption(OPTION_NAME_DEBUGRENDERPASS, 0);
		optionBackgroundColorR = (Float) getOption(OPTION_NAME_BACKGROUND_COLOR_R, 1.0f);
		optionBackgroundColorG = (Float) getOption(OPTION_NAME_BACKGROUND_COLOR_G, 1.0f);
		optionBackgroundColorB = (Float) getOption(OPTION_NAME_BACKGROUND_COLOR_B, 1.0f);
		optionBackgroundAlpha = (Float) getOption(OPTION_NAME_BACKGROUND_ALPHA, 1.0f);
		optionShowBGImage = (Boolean) getOption(OPTION_NAME_SHOW_BACKGROUND_IMAGE, true);
	}

	@Override
	protected void render(int flags) throws InterruptedException {
		// obtain callback that was last set
		ObjectConsumer<? super RenderedImage> callback;
		synchronized (callbackLock) {
			callback = this.callback;
			this.callback = null;
		}
		
		// Need to find extent of the scene!
		getView3D().setExtent(null, Float.NaN);
		// get time when render was called
		// long t0 = Utils.nanoTime ();

		visible = ((boolean[]) View.visibleLayers$FIELD.getObject(getView()));

		// obtain current GL instance
		GL gl = canvas.getGL();
		setGL(gl);

		// check if the canvas changed, i.e. in dual-head configurations
		// when the window is moved from one monitor to another one
		if (canvasChanged) {
			canvasChanged = false;
			dlSphere = 0;

			// check if VBOs are supported
			supportsVBO = gl
					.isExtensionAvailable("GL_ARB_vertex_buffer_object");
			if (DEBUG) {
				System.err.println("supportsVBO = " + supportsVBO);
			}
			supportsVBO = false;
		}

		// compare with old GL context
		GLContext context = canvas.getContext();
		if (context != oldContext) {
			// GL context changed
			// this results in all textures being lost
			// so recreate them
			textureManager.deleteTextures(gl);
			// and reset OpenGL error code
			setUpContext(canvas.getContext());
			gl.glGetError();
			oldContext = context;
		}

		if (reshaped) {
			reshaped = false;
			resize();
		}

		// reset reshaped

		// set clear color for frame buffer
		// XXX: Error in OGL Profiler
		gl.glClearColor(0.75f, 0.75f, 0.75f, 0.0f);

		// get viewport size
		int w = canvas.getWidth();
		int h = canvas.getHeight();
		// gl.glViewport (0, 0, w, h);
		((View3D) getView()).getCanvasCamera().setDimension(w, h);

		// clear frame buffer
		gl.glClear(GL.GL_COLOR_BUFFER_BIT);

		// check if there is a rendered background image to draw
		synchronized (imageLock) {
			if (img != null) {
				// check if image was modified since last conversion
				if (imgChanged) {
					grabBackground(gl);
				}

				// draw the background image to the screen
				drawBackground(gl);

				// if a rendered image was available, then send that one
				// to the callback as a buffered image
				if (callback != null) {
					callback.consume(convert(img));
				}

				// delete rendered image if scene was changed,
				// otherwise prevent drawing the scene on top of the image
				if ((flags & (SCENE | CHANGED)) == (SCENE | CHANGED)) {
					img = null;
				} else {
					return;
				}
			}
		}

		Measures.getInstance().startTimer();

		// clear depth buffer
		gl.glClear(GL.GL_DEPTH_BUFFER_BIT);

		// set viewport transformation
		gl.glMatrixMode(GL.GL_PROJECTION);
		Camera c = ((View3D) getView()).getCamera();
		Matrix4d m = new Matrix4d();
		c.getViewToClipTransformation(m);
		double aspect = (double) w / (double) h;
		m.mul(new Matrix4d(1, 0, 0, 0, 0, aspect, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1));
		gl.glLoadMatrixd(toGLMatrix(m), 0);
		gl.glMatrixMode(GL.GL_MODELVIEW);

		// check if the scene graph changed
		int newStamp = getView().getGraph().getStamp();
		if (newStamp != oldStamp) {
			// remeber new stamp value
			oldStamp = newStamp;
			// IMP3D.fitCamera(null, null, getView3D());
			// return;
		}

		// first walk of scene graph, visit all objects
		curHighlight = 0;

		try {
			// first walk (deferred pass & lightning(may also contain shadows) )
			renderScene();

			// second walk, visit highlighted objects
			// so they can be overdrawn with wireframe version
			ArrayPath path = new ArrayPath(getView().getGraph());
			ViewSelection.Entry[] s = ViewSelection.get(getView()).getAll(-1);
			for (int i = 0; i < s.length; i++) {
				Path p = s[i].getPath();
				curHighlight = s[i].getValue();
				visitor.init(getRenderGraphState(), glState.getWorldToView(), p
						.getNodeAndEdgeCount(), true);

				GraphUtils.acceptPath(p, visitor, path);
			}

			// disable lighting for tools
			disableLighting(gl);

			// disable depth buffer for tools
			gl.glDisable(GL.GL_DEPTH_TEST);

			
			
			// third walk through the tools subgraph (i.e. the arrows to move
			// objects)
			de.grogra.imp.edit.Tool tool = getView().getActiveTool();
			if (tool != null) {
				curHighlight = 0;
				visitor.init(GraphManager.STATIC_STATE, glState
						.getWorldToView(), 0, false);

				path.clear(GraphManager.STATIC);
				for (int i = 0; i < tool.getToolCount(); i++) {
					GraphManager.acceptGraph(tool.getRoot(i), visitor, path);
				}
			}

			// enable lighting
			enableLighting(gl);
			gl.glEnable(GL.GL_LIGHT0);

//			glState.printPoints();

			// enable depth buffer
			gl.glEnable(GL.GL_DEPTH_TEST);

			// draw axes of coordinates
			if (optionShowAxes)
				drawAxes(gl, c);

			if (optionShowDisplaySize)
				drawDisplaySize(gl, c);

		} catch (WrapException e) {
			if (e.getCause() instanceof InterruptedException) {
				throw (InterruptedException) e.getCause();
			}
			throw e;
		} finally {
//			gl.glFlush();
			gl.glFinish();
		}

		 Measures.getInstance().stopTimer(this);
		 if(Measures.getInstance().shouldRedraw())
			 repaint (ALL);

		// if a screenshot was requested, read pixels from framebuffer
		// and send them to the callback
		if (callback != null) {
			//callback.consume(Screenshot.readToBufferedImage(w, h));
			callback.consume(readCurrentToBufferedImage(gl));
		}
	}


	/**
	 * Function to store the content of a renderbuffer as HDR image.
	 * @param gl The current GL object
	 * @return The image as instance of class BufferedImage
	 */
	private BufferedImage readCurrentToBufferedImage(GL gl) {
		   int readbackType = GL.GL_BGRA;

			DataBufferFloat buffer = new DataBufferFloat (glState.width * glState.height * 4);
			//BandedSampleModel sampleModel = new BandedSampleModel (buffer.getDataType (), glState.width, glState.height, 4);
			SampleModel sampleModel = new PixelInterleavedSampleModel(buffer.getDataType(), glState.width, glState.height, 4, glState.width*4, new int[] {2, 1, 0, 3}); 
			WritableRaster raster = Raster.createWritableRaster (sampleModel, buffer, null);
			ColorSpace cs = ColorSpace.getInstance (ColorSpace.CS_sRGB);
			ComponentColorModel cm = new ComponentColorModel (cs, true, false, Transparency.TRANSLUCENT, buffer.getDataType ());
			BufferedImage image = new BufferedImage (cm, raster, false, null);
		    
			glState.getHDRFBO().bind(glState);
			gl.glReadBuffer(GL.GL_COLOR_ATTACHMENT0_EXT + glState.getFloatRT());
			
		    PixelStorageModes psm = new PixelStorageModes();
		    psm.save(gl);
		    gl.glReadPixels(0, 0, glState.width, glState.height, readbackType,
		                    GL.GL_FLOAT,
		                    FloatBuffer.wrap(buffer.getData()));
			psm.restore(gl);
			
			glState.setFBO(0);
			
		    ImageUtil.flipImageVertically(image);
		    return image;		
	}

	private static int glGetInteger(GL gl, int pname, int[] tmp) {
		gl.glGetIntegerv(pname, tmp, 0);
		return tmp[0];
	}

	static class PixelStorageModes {
		int packAlignment;
		int packRowLength;
		int packSkipRows;
		int packSkipPixels;
		int packSwapBytes;
		int[] tmp = new int[1];

		void save(GL gl) {
			packAlignment = glGetInteger(gl, GL.GL_PACK_ALIGNMENT, tmp);
			packRowLength = glGetInteger(gl, GL.GL_PACK_ROW_LENGTH, tmp);
			packSkipRows = glGetInteger(gl, GL.GL_PACK_SKIP_ROWS, tmp);
			packSkipPixels = glGetInteger(gl, GL.GL_PACK_SKIP_PIXELS, tmp);
			packSwapBytes = glGetInteger(gl, GL.GL_PACK_SWAP_BYTES, tmp);

			gl.glPixelStorei(GL.GL_PACK_ALIGNMENT, 1);
			gl.glPixelStorei(GL.GL_PACK_ROW_LENGTH, 0);
			gl.glPixelStorei(GL.GL_PACK_SKIP_ROWS, 0);
			gl.glPixelStorei(GL.GL_PACK_SKIP_PIXELS, 0);
			gl.glPixelStorei(GL.GL_PACK_SWAP_BYTES, 0);
		}

		void restore(GL gl) {
			gl.glPixelStorei(GL.GL_PACK_ALIGNMENT, packAlignment);
			gl.glPixelStorei(GL.GL_PACK_ROW_LENGTH, packRowLength);
			gl.glPixelStorei(GL.GL_PACK_SKIP_ROWS, packSkipRows);
			gl.glPixelStorei(GL.GL_PACK_SKIP_PIXELS, packSkipPixels);
			gl.glPixelStorei(GL.GL_PACK_SWAP_BYTES, packSwapBytes);
		}
	}

	/**
	 * Initialise opengl state and set default values. All functions can assume
	 * those values being set upon call (i.e. MatrixMode as GL_MODELVIEW). If a
	 * function changes any of those values, it has to restore its state before
	 * calling another function or exiting.
	 * This also wraps DebugGL arround the current GL-Object if {@link GLSLDisplay#DEBUG}
	 * is set to true resulting in detailed Debug-Output if an GLError occurs. 
	 */
	@Override
	public void init(GLAutoDrawable d) {
		if (DEBUG)
			d.setGL(new DebugGL(d.getGL()));
			//d.setGL(new TraceGL(new DebugGL(d.getGL()), System.err));
			//d.setGL(new DebugGL(new TraceGL(d.getGL(), System.err)));
		super.init(d);
	}

	/**
	 * Prepare settings before doing any drawing calls. For OpenGL (Proteus)
	 * this function will only set a color. If the object should be highlighted, it will
	 * switch to drawing lines instead of surfaces.
	 * 
	 * Note: This does not change any texture-dependent settings
	 * 
	 * @param gl
	 * @param s
	 * @param highlight
	 *            one of the constants defined in class ViewSelection
	 * @return the texture that is used to draw the object. By default null
	 */
	@Override
	Texture prologue(GL gl, Shader s, int highlight) {
		// activate texture mapping
		Texture tex = null;

		int color = 0x00B0B0B0;
		if (s != null)
			color = s.getAverageColor();

		// if texturing is enabled, use white as vertex color instead
		if (tex != null) {
			color = -1;
		}

		// get the drawing color and set it in opengl
		// color is an int encoding ARGB, which is separated into red, green,
		// blue and alpha
		byte red = (byte) ((color >> 16) & 0xFF);
		byte green = (byte) ((color >> 8) & 0xFF);
		byte blue = (byte) ((color >> 0) & 0xFF);
		byte alpha = (byte) ((color >> 24) & 0xFF);
		highlightPrologue(highlight, gl, red, green, blue, alpha);

		return tex;
	}

	/**
	 * Reset settings changed by prologue() to their defaults. For OpenGL (Proteus)
	 * this only calls {@link GLDisplay#highlightPrologue(int, GL)}
	 * @param gl
	 * @param s
	 * @param tex
	 *            texture that was returned by prologue()
	 * @param highlight
	 *            one of the constants defined in class ViewSelection
	 * @see GLDisplay#epilogue(GL, Shader, Texture, int)
	 */
	@Override
	void epilogue(GL gl, Shader s, Texture tex, int highlight) {
		// cleanupTexture (gl, s, tex);
		highlightEpilogue(highlight, gl);
	}

	@Override
	public void drawBoxImpl(GL gl, float x0, float y0, float z0, float x1,
			float y1, float z1) {
		super.drawBoxImpl(gl, x0, y0, z0, x1, y1, z1);
	}

	// static final float PLANE_SIZE = 100000.0f;
	// static final float PLANE_SIZE = 1000.0f;
	static final float PLANE_SIZE = 100.0f;

	@Override
	void drawPlaneImpl(GL gl, int size, int uc, int vc) {
		gl.glBegin(GL.GL_QUAD_STRIP);
		gl.glNormal3f(0, 0, 1);
		for (int v = 0; v < vc; v++) {
			float y0 = size * ((float) v / (float) vc - 0.5f);
			float y1 = size * ((float) (v + 1) / (float) vc - 0.5f);
			for (int u = 0; u <= uc; u++) {
				float x = size * ((float) u / (float) uc - 0.5f);
				gl.glTexCoord2f(size * u / (float) uc, size * (v + 1)
						/ (float) vc);
				gl.glVertex3f(x, y1, 0);
				gl.glTexCoord2f(size * u / (float) uc, size * v / (float) vc);
				gl.glVertex3f(x, y0, 0);
			}
		}
		gl.glEnd();
	}

	@Override
	public void drawPlane(Shader s, int highlight, Matrix4d t) {
		// get correct (and probibly derived) shader and transformation
		s = getShader(s);
		t = getTransformation(t);

		// get opengl context
		GL gl = canvas.getGL();

		// apply transformation
		gl.glPushMatrix();
		gl.glLoadMatrixd(toGLMatrix(t), 0);

		// setup color/texture
		Texture tex = prologue(gl, s, highlight);
		
		// draw the plane
		drawPlaneImpl(gl, (int) PLANE_SIZE, 1, 1);

		// cleanup color/texture
		epilogue(gl, s, tex, highlight);

		// restore previous state
		gl.glPopMatrix();
	}

	@Override
	public void drawPolygons(Polygonizable pz, Object obj, boolean asNode,
			Shader s, int highlight, Matrix4d t) {
		drawPolygons(pz, obj, asNode, s, highlight, t, -1, true, true);
	}

	//TODO: reduce parameters
	/**
	 * Draw a polygonizable Object. This Method adds additional parameters for dealing
	 * with different culling modes set by OpenGL. 
	 * @param pz
	 * @param obj
	 * @param asNode
	 * @param s
	 * @param highlight
	 * @param t Transformation matrix. Input for {@link GLSLDisplay#getTransformation(Matrix4d)}
	 * @param defaultCulledSide Default state for culling. This is one of GL.FRONT, GL.GL_BACK
	 * @param cullingEnabled True if culling is currently enabled in OpenGL. False else.
	 * @param normalMode True if this is used for drawing visible geometry. False if used
	 * for drawing into Shadow Map.
	 * @see GLDisplay#drawPolygons(Polygonizable, Object, boolean, Shader, int, Matrix4d)
	 */
	public void drawPolygons(Polygonizable pz, Object obj, boolean asNode,
			Shader s, int highlight, Matrix4d t, int defaultCulledSide,
			boolean cullingEnabled, boolean normalMode) {
		if ((polyCache != null)
				&& (polyCache.getGraphState() != getRenderGraphState())) {
			polyCache.clear();
			polyCache = null;
		}
		if (polyCache == null) {
			polyCache = new PolygonizationCache(getRenderGraphState(),
					Polygonization.COMPUTE_NORMALS | Polygonization.COMPUTE_UV,
					10, true);
		}

		// get correct (and probibly derived) shader and transformation
		s = getShader(s);
		t = getTransformation(t);

		PolygonArray polys = polyCache.get(obj, asNode, pz);

		// obtain the buffer(s) for the polygons
		// or create such buffers if not already done so
		CacheData data;
		if (polys.wasCleared() || !(polys.userObject instanceof CacheData)) {
			data = new CacheData();
			data.polygonSize = polys.polygons.size;

			if (data.polygonSize > 0) {
				{
					// convert arrays to buffers
					data.ib = newByteBuffer(polys.polygons.size * 4)
							.asIntBuffer();
					polys.polygons.writeTo(data.ib);

					data.vb = newByteBuffer(polys.vertices.size * 4)
							.asFloatBuffer();
					polys.vertices.writeTo(data.vb);

					data.nb = newByteBuffer(polys.normals.size);
					polys.normals.writeTo(data.nb);

					data.uvb = newByteBuffer(polys.uv.size * 4).asFloatBuffer();
					polys.uv.writeTo(data.uvb);
				}
			}
			polys.userObject = data;
		} else {
			data = (CacheData) polys.userObject;
		}

		if (data.polygonSize > 0) {
			{
				data.ib.rewind();
				data.vb.rewind();
				data.nb.rewind();
				data.uvb.rewind();
			}

			// get GL instance
			GL gl = canvas.getGL();

			if (defaultCulledSide != -1) {
				switch (polys.visibleSides) {
				case Attributes.VISIBLE_SIDES_FRONT:
					if (!cullingEnabled) {
						gl.glEnable(GL.GL_CULL_FACE);
						gl.glCullFace(GL.GL_BACK);
					} else if (defaultCulledSide == GL.GL_FRONT)
						return;
					break;
				case Attributes.VISIBLE_SIDES_BACK:
					if (!cullingEnabled) {
						gl.glEnable(GL.GL_CULL_FACE);
						gl.glCullFace(GL.GL_FRONT);
					} else if (defaultCulledSide == GL.GL_BACK)
						return;
					break;
				}
			} else
				switch (polys.visibleSides) {
				case Attributes.VISIBLE_SIDES_BACK:
					gl.glCullFace(GL.GL_FRONT);
					// gl.glLightModeli (GL.GL_LIGHT_MODEL_TWO_SIDE, 1);
					break;
				case Attributes.VISIBLE_SIDES_BOTH:
					gl.glDisable(GL.GL_CULL_FACE);
					// gl.glLightModeli (GL.GL_LIGHT_MODEL_TWO_SIDE, 1);
					break;
				}

			// apply transformation
			gl.glMatrixMode(GL.GL_MODELVIEW);
			gl.glPushMatrix();
			gl.glLoadMatrixd(toGLMatrix(t), 0);

			// setup highlight/texture
			Texture tex = prologue(gl, s, highlight);

			// enable client states for vertex, normal und texcoord
			gl.glEnableClientState(GL.GL_VERTEX_ARRAY);
			gl.glEnableClientState(GL.GL_NORMAL_ARRAY);
			gl.glEnableClientState(GL.GL_TEXTURE_COORD_ARRAY);

			{
				// render using vertex arrays

				// draw the object
				gl.glVertexPointer(polys.dimension, GL.GL_FLOAT, 0, data.vb);
				gl.glNormalPointer(GL.GL_BYTE, 0, data.nb);
				gl.glTexCoordPointer(2, GL.GL_FLOAT, 0, data.uvb);

				gl.glDrawElements((polys.edgeCount == 3) ? GL.GL_TRIANGLES
						: GL.GL_QUADS, data.polygonSize, GL.GL_UNSIGNED_INT,
						data.ib);
			}

			// disable client states
			gl.glDisableClientState(GL.GL_VERTEX_ARRAY);
			gl.glDisableClientState(GL.GL_NORMAL_ARRAY);
			gl.glDisableClientState(GL.GL_TEXTURE_COORD_ARRAY);

			epilogue(gl, s, tex, highlight);

			if (defaultCulledSide != -1) {
				if (!cullingEnabled) {
					if (polys.visibleSides == Attributes.VISIBLE_SIDES_FRONT
							&& defaultCulledSide != GL.GL_BACK) {
						gl.glDisable(GL.GL_CULL_FACE);
						gl.glCullFace(defaultCulledSide);
					} else if (polys.visibleSides == Attributes.VISIBLE_SIDES_BACK
							&& defaultCulledSide != GL.GL_FRONT) {
						gl.glDisable(GL.GL_CULL_FACE);
						gl.glCullFace(defaultCulledSide);
					}
				}
			} else
				switch (polys.visibleSides) {
				case Attributes.VISIBLE_SIDES_BACK:
					gl.glCullFace(GL.GL_BACK);
					// gl.glLightModeli (GL.GL_LIGHT_MODEL_TWO_SIDE, 0);
					break;
				case Attributes.VISIBLE_SIDES_BOTH:
					gl.glEnable(GL.GL_CULL_FACE);
					// gl.glLightModeli (GL.GL_LIGHT_MODEL_TWO_SIDE, 0);
					break;
				}

			// restore previous state
			gl.glMatrixMode(GL.GL_MODELVIEW);
			gl.glPopMatrix();
		}
	}

	// Switched Sides for Parallelogram
	@Override
	public void drawParallelogram (float length, Vector3f axis, float scaleU,
			float scaleV, Shader s, int highlight, Matrix4d t)
	{
		// get correct (and probibly derived) shader and transformation
		s = getShader (s);
		t = getTransformation (t);

		// get opengl context
		GL gl = canvas.getGL ();

		// apply transformation
		gl.glPushMatrix ();
		gl.glLoadMatrixd (toGLMatrix (t), 0);

		// setup color/texture
		Texture tex = prologue (gl, s, highlight);

		// calculate normal vector for surface
		Vector3f normal = new Vector3f (0, 0, length);
		normal.cross (axis, normal);
	
		gl.glDisable (GL.GL_CULL_FACE);

		// draw the parallelogram
		gl.glBegin (GL.GL_QUADS);

		gl.glNormal3f (-normal.x, -normal.y, -normal.z);
		gl.glTexCoord2f (0, scaleV);
		gl.glVertex3f (-axis.x, -axis.y, length - axis.z);
		gl.glTexCoord2f (scaleU, scaleV);
		gl.glVertex3f (axis.x, axis.y, length + axis.z);
		gl.glTexCoord2f (scaleU, 0);
		gl.glVertex3f (axis.x, axis.y, axis.z);
		gl.glTexCoord2f (0, 0);
		gl.glVertex3f (-axis.x, -axis.y, -axis.z);

		gl.glEnd ();

		gl.glEnable (GL.GL_CULL_FACE);

		// cleanup color/texture
		epilogue (gl, s, tex, highlight);

		// restore previous state
		gl.glPopMatrix ();
	}
	
	@Override
	public void drawGrid(GL gl) {
		super.drawGrid(gl);
	}
	
	/**
	 * construct an orthogonal view matrix for easing full screen Quad drawing
	 * @param gl Current GL Object. Used to issue OpenGL commands.
	 * @param width Width of the orthogonal projection in OpenGL units.
	 * @param height Height of the orthogonal projection in OpenGL units. 
	 */
	public static void ViewOrtho(GL gl, int width, int height) // Set Up An Ortho View
	{
		gl.glMatrixMode(GL.GL_PROJECTION); // Select Projection
		gl.glPushMatrix(); // Push The Matrix
		gl.glLoadIdentity(); // Reset The Matrix
		gl.glOrtho(0, width, height, 0, -1, 1); // Select Ortho Mode
		gl.glMatrixMode(GL.GL_MODELVIEW); // Select Modelview Matrix
		gl.glPushMatrix(); // Push The Matrix
		gl.glLoadIdentity(); // Reset The Matrix
	}

	/**
	 * change view matrix back to default
	 * @param gl Current GL Object. Used to issue OpenGL commands.
	 */
	public static void ViewPerspective(GL gl) // Set Up A Perspective View
	{
		gl.glMatrixMode(GL.GL_PROJECTION); // Select Projection
		gl.glPopMatrix(); // Pop The Matrix
		gl.glMatrixMode(GL.GL_MODELVIEW); // Select Modelview
		gl.glPopMatrix(); // Pop The Matrix
	}
	
	@Override
	public void drawRectangle (int x, int y, int w, int h, Tuple3f color)
	{
		GL gl = canvas.getGL();
		gl.glDisable(GL.GL_DEPTH_TEST);
		gl.glDisable(GL.GL_LIGHTING);
		ViewOrtho(gl, canvas.getWidth(), canvas.getHeight());
		gl.glColor3f(color.x, color.y, color.z);
		gl.glBegin(GL.GL_LINE_LOOP); {
			gl.glVertex2f(x, y);
			gl.glVertex2f(x+w, y);
			gl.glVertex2f(x+w, y+h);
			gl.glVertex2f(x, y+h);			
			
		} gl.glEnd();
		ViewPerspective(gl);
		gl.glEnable(GL.GL_DEPTH_TEST);
		gl.glEnable(GL.GL_LIGHTING);
	}

	@Override
	public void fillRectangle (int x, int y, int w, int h, Tuple3f color)
	{
		GL gl = canvas.getGL();
		gl.glDisable(GL.GL_DEPTH_TEST);
		gl.glDisable(GL.GL_LIGHTING);
		ViewOrtho(gl, canvas.getWidth(), canvas.getHeight());
		gl.glColor3f(color.x, color.y, color.z);
		gl.glBegin(GL.GL_QUADS); {
			gl.glVertex2f(x, y);
			gl.glVertex2f(x, y+h);			
			gl.glVertex2f(x+w, y+h);
			gl.glVertex2f(x+w, y);
		} gl.glEnd();
		ViewPerspective(gl);
		gl.glEnable(GL.GL_DEPTH_TEST);
		gl.glEnable(GL.GL_LIGHTING);
	}

	@Override
	public void drawPoint(Tuple3f origin, int pixelSize, Tuple3f color,
			int highlight, Matrix4d t) {
		// check if drawing points is enabled
		if (optionShowPoints) {
			// get correct (and probibly derived) transformation
			t = getTransformation(t);

			// get opengl context
			GL gl = canvas.getGL();

			// calculate scale factor for octahedron (represents point)
			// so that the requested pixel size will result
			float scale = (float) pixelSize / (float) estimateScaleAt(origin);
			Matrix4d m = new Matrix4d();
			m.set((double) scale, new Vector3d(origin));
			m.mul(t, m);

			// apply transformation
			gl.glPushMatrix();
			gl.glLoadMatrixd(toGLMatrix(m), 0);

			// set the drawing color for opengl to the point color
			gl.glColor3f(color.x, color.y, color.z);

			// disable lighting for points
			// (points are used to display point lights)
			disableLighting(gl);

			// draw a sphere instead of a point
			// the problem with gl.glBegin(GL.GL_POINTS) is, that some
			// implementations
			// of opengl only support point sizes of just 1.0
			// drawSphereImpl (gl, 4, 2);
			// drawSphereImpl (gl, 8, 8);
			// draw the sphere
			dlSphere = drawWithDisplayList(dlSphere, gl,
					new SphereDisplayListRenderable(gl), LOD_LEVELS, 4);

			// enable lighting
			enableLighting(gl);

			// restore previous state
			gl.glPopMatrix();
		}
	}

	@Override
	public Matrix4d getTransformation(Matrix4d t) {
		// TODO Auto-generated method stub
		return super.getTransformation(t);
	}

	@Override
	protected void optionValueChanged(String name, Object value) {
		// System.out.println (name + " = " + value);
		if (OPTION_NAME_SHOWSKY.equals(name)) {
			optionShowSky = (Boolean) (value);
			repaint(ALL);
		} else if (OPTION_NAME_SHOWSHADOWS.equals(name)) {
			optionShowShadows = (Boolean) (value);
			repaint(ALL);
		} else if (OPTION_NAME_TONEMAPPING.equals(name)) {
			tonemapping = ((Number) value).intValue();
			repaint(ALL);
		} else if (OPTION_NAME_BRIGHTNESS.equals(name)) {
			brightness = (Float) (value);
			repaint(ALL);
		} else if (OPTION_NAME_AUTOADJUSTBRIGHTNESS.equals(name)) {
			optionAutoAdjustBrightness = (Boolean) (value);
			repaint(ALL);
		} else if (OPTION_NAME_EDGEFILTERING.equals(name)) {
			optionEdgeFiltering = (Boolean) (value);
			repaint(ALL);
		} else if (OPTION_NAME_SHADERANTIALIASING.equals(name)) {
			optionShaderAntialiasing = (Boolean) (value);
			glState.invalidateCache();
			repaint(ALL);
		} else if (OPTION_NAME_ALTDRAWING.equals(name)) {
			optionAltDrawing = (Boolean) (value);
			glState.invalidateCache();
			repaint(ALL);
		} else if (OPTION_NAME_PHYSICALLIGHTING.equals(name)) {
			optionPhysicalLighting = (Boolean) (value);
			repaint(ALL);
		} else if (OPTION_NAME_DIFFUSESKYLIGHT.equals(name)) {
			optionShowDiffuseSkyLight = (Boolean) (value);
			repaint(ALL);
		} else if (OPTION_NAME_MAXDEPTH.equals(name)) {
			optionMaxDepth = (Integer) (value);
			repaint(ALL);
		} else if (OPTION_NAME_DEBUGRENDERPASS.equals(name)) {
			optionDebugRenderPass = (Integer) (value);
			repaint(ALL);
		}
		else if (OPTION_NAME_BACKGROUND_COLOR_R.equals (name))
		{
			optionBackgroundColorR = (Float) (value);
			repaint (ALL);
		}
		else if (OPTION_NAME_BACKGROUND_COLOR_G.equals (name))
		{
			optionBackgroundColorG = (Float) (value);
			repaint (ALL);
		}
		else if (OPTION_NAME_BACKGROUND_COLOR_B.equals (name))
		{
			optionBackgroundColorB = (Float) (value);
			repaint (ALL);
		}
		else if (OPTION_NAME_BACKGROUND_ALPHA.equals (name))
		{
			optionBackgroundAlpha = (Float) (value);
			repaint (ALL);
		}
		else if (OPTION_NAME_SHOW_BACKGROUND_IMAGE.equals(name)) {
			optionShowBGImage = (Boolean) (value);
			repaint(ALL);
		}
		else {
			super.optionValueChanged(name, value);
		}
	}

	/**
	 * @return true, if grid should be rendered. false, else
	 */
	public boolean isOptionShowGrid() {
		return optionShowGrid;
	}

	/**
	 * @return true, if the background (checkboard) image should be rendered. false, else
	 */
	public boolean isOptionShowBGImage() {
		return optionShowBGImage;
	}
	
	/**
	 * @return red value of background color
	 */
	public float getBackgroundColorR() {
		return optionBackgroundColorR;
	}
	
	/**
	 * @return green value of background color
	 */
	public float getBackgroundColorG() {
		return optionBackgroundColorG;
	}
	
	/**
	 * @return blue value of background color
	 */
	public float getBackgroundColorB() {
		return optionBackgroundColorB;
	}
	
	/**
	 * @return alpha value of background
	 */
	public float getBackgroundAlpha() {
		return optionBackgroundAlpha;
	}
	
	/**
	 * @return true, if scene should be rendered with all lights. false, only
	 *         use default directional light.
	 */
	public boolean isOptionLighting() {
		return lightingOn;
	}

	/**
	 * @return true, if scene sky should be rendered.
	 */
	public boolean isOptionShowSky() {
		return optionShowSky;
	}

	/**
	 * @return true, if shadows should be rendered and displayed.
	 */
	public boolean isOptionShowShadows() {
		return optionShowShadows;
	}

	/**
	 * @return true, if edge-filtering should be used. This Option
	 * is currently unused since a working filtering approach was not
	 * implemented.
	 */
	public boolean isOptionEdgeFiltering() {
		return optionEdgeFiltering;
	}

	/**
	 * @return true, if alternative drawing methods should be called.
	 * Up to now this will only result in infinite planes.
	 */
	public boolean isOptionAltDrawing() {
		return optionAltDrawing;
	}

	/**
	 * @return true, if lights intensity should decrease by the squared
	 * distance from the lights source.
	 */
	public boolean isOptionPhysicalLighting() {
		return optionPhysicalLighting;
	}

	/**
	 * @return true, if diffuse light of sky-Nodes should be approximated.
	 */
	public boolean isOptionShowDiffuseSkyLight() {
		return optionShowDiffuseSkyLight;
	}

	/**
	 * @return true, if anti-aliasing material-shaders should be used.
	 */
	public boolean isOptionShaderAntialiasing() {
		return optionShaderAntialiasing;
	}

	/**
	 * @return true, if brightness should be automatically adjusted for 
	 * the rendered image.
	 */
	public boolean isOptionAutoAdjustBrightness() {
		return optionAutoAdjustBrightness;
	}

	/**
	 * @return the brightness factor used to brighten the rendered
	 * image.
	 */
	public float getBrightness() {
		return brightness;
	}

	/**
	 * @return the index of the choosen tonemapping algorithm. For now
	 * this is:
	 *     0: Linear tonemapping
	 *     1: DDR (Dynamic Range Reduction). See paper at <a href="http://portal.acm.org/citation.cfm?id=1032534">link</a>.
	 */
	public int getTonemapping() {
		return tonemapping;
	}

	/**
	 * @return the index of a renderpass, which should be displayed.
	 * This will render the content of each HDR- and DeferredShading-FBO
	 * as seen at the specified RenderPass to the screen.
	 */
	public int getDebugRenderPass() {
		return optionDebugRenderPass;
	}

	/**
	 * @return Number of Depth-Peeling passes used to display transparent
	 * materials.
	 */
	public int getMaxDepth() {
		return optionMaxDepth;
	}

	/**
	 * @return The current active Visitor to traverse the Scene-Tree.
	 */
	public GLVisitor getVisitor() {
		return visitor;
	}

	
	/**
	 * Sets the active visitor. The previous visitor will not be saved. 
	 * Use {@link #getVisitor()} to store a reference.
	 * @param visitor The visitor Object that replaces the active visitor.
	 */
	public void setVisitor(GLVisitor visitor) {
		this.visitor = visitor;
	}

	/**
	 * @return The Manager used to the Textures for each translated material. 
	 */
	public TextureManager getTextureManager() {
		return textureManager;
	}

	boolean[] visible = null;

	/**
	 * Tests if the given layer is currently visible.
	 * @param layer The layer that should be tested.
	 * @return true, if the layer is visible.
	 */
	public boolean isVisible(int layer) {
		return (layer < 0) || (layer >= visible.length) || visible[layer];
	}

	/**
	 * Returns the OpenGLState associated with the current GLContext.
	 * @return The current OpenGLState.
	 * @see OpenGLState
	 */
	public OpenGLState getCurrentGLState() {
		return glState;
	}

	public static int getDepthStencilSetup() {
		return DEPTH_STENCIL_SETUP;
	}
	
	/************/

	private GLContext oldContext;

	OpenGLState glState = new OpenGLState();

	static final RenderPass fqrp;

	// FullTestRenderPass ftrp = new FullTestRenderPass();

	/**
	 * Initialize OpenGL (Proteus). This will initialize all Collections 
	 */
	public void init() {
		GLSLDisplay.printDebugInfoN("Initializing FBO:");

		glState.initSize(getView().getSize().width, getView()
				.getSize().height);

		glState.getFboManager().setupFBO(glState);

		glState.initLineCache(this);

		LightCollection.initMap();
		ShadowLightCollection.initMap();
		MaterialCollection.initMap();

		GLSLChannelMap.initMap();
		FloatToFloatCollection.initMap();
		Transform3DCollection.initMap();
	}

	/**
	 * Sets the gl object as current active GL object. Effectively this will call 
	 * {@link OpenGLState#setGL(GL)}.
	 * @param gl The GL object
	 */
	public void setGL(GL gl) {
		glState.setGL(gl);
	}

	/**
	 * If called, all associated FBOs are resized to the current viewports size.
	 */
	public void resize() {
		glState.getFboManager().resize(this, glState);
		//until "grey screen" is fixed
		repaint(ALL);
	}

	/**
	 * Setter for GL. This will also reset glState and cleanup the Java-Side of 
	 * the used OpenGL-Objects.
	 * 
	 * @param context
	 *            The new GL-context that should be used for all actions.
	 */
	public void setUpContext(GLContext context) {
		if (this.oldContext != context) {
			if (context != null) {
				// glState.makeContextCurrent();
				glState.cleanUp(true);
				GLSLDisplay
						.printDebugInfoN("Context changed - deleting Java-References:");
				glState.resetCache = true;
				this.oldContext = context;
			}
			init();
		}
	}

	Matrix4d LightWorldToView = new Matrix4d();
	Matrix4d LightViewToClip = new Matrix4d();

	int i = 0;

	/**
	 * This method renders the Scene. This includes all objects of the Scene-Graph.
	 * Additional rendering like highlighting of objects and the size of the current
	 * viewport will be handled by {@link GLDisplay#render(int)}.
	 */
	public void renderScene() {
		GLSLDisplay.printDebugInfoN("------ START ------");

		glState.updateStamp(getView().getGraph().getStamp());
		glState.updateTransformations(this);
		if (GLSLDisplay.DEBUG)
			glState.startClock();
		fqrp.process(this, glState, null);
		if (GLSLDisplay.DEBUG) {
			long diff = glState.printClock("Full Pass took: ");
			System.out.printf("Thats >%d FPS\n", 1000000 / diff);
			glState.popClock();
		}
		GLSLDisplay.printDebugInfoN("------ END ------");
		// if(i++ < 1000)
		// System.out.print(System.nanoTime() - glState.popClock()+";");
		// else
		// System.out.println();
		// glState.testGLError("Errors on pass: ");
		// glState.printGPUMemoryUsage(disp);
		// fsrp.process(disp, glState, null);
		// ftrp.process(disp, glState, null);
	}

	/**
	 * Searches Shader-Cache for a GLSL-Shader corresponding to the given
	 * Shader s. If no GLSL-Shader is found one is created. The Shader is then
	 * activated.
	 * @param s The GroIMP-Shader.
	 */
	public void findAndActivateShader(Shader s) {
		glState.csc.findAndActivateShader(glState, this, glState
				.getCurrentShaderConfiguration(), s);
	}

	/**
	 * Searches Shader-Cache for a GLSL-Shader corresponding to the given
	 * Shader s. If no GLSL-Shader is found one is created.
	 * @param s The GroIMP-Shader.
	 * @return The GLSL-Shader.
	 */ 
	public GLSLManagedShader findShader(Shader s) {
		return glState.csc.findShader(glState, this, glState
				.getCurrentShaderConfiguration(), s);
	}

	// TODO : HACK!
	/**
	 * Setup a sky. This method is used by a visitor to store a sky-node.
	 * Since it is considered a hack this method will be removed in upcoming
	 * commits of the source-code.
	 * @param node
	 * @return false, if a sky has already been set.
	 */
	public boolean setupBGShader(Sky node) {
		glState.setupBGShader(node.getShader());
		if (!glState.BGFound)
			return false;
		if (node.getShader() instanceof Light)
			glState.setupBGPowerDensity(node.getPowerDensity());
		else
			glState.setupBGPowerDensity(node.getPowerDensity() / 3.f);
		return true;
	}
}