#if (!$generate)
	#set ($generate = true)
	#foreach ($type in ["int", "long", "longToInt", "Object"])
		#set ($Type = $pp.firstToUpperCase($type))
		#if ($type == "longToInt")
			#set ($type = "long")
			#set ($V = "int")
			#set ($l2i = true)
			#set ($vnull = "0")
		#else
			#set ($V = "V")
			#set ($l2i = false)
			#set ($vnull = "null")
		#end
		#if ($type == "Object")
			#set ($object = true)
			#set ($NAME = "XHashMap")
			#set ($null = "null")
			#set ($equal = "(e.hashCode == hashCode) && equals (key, e.key)")
			#set ($sig = "<K,V>")
			#set ($type = "K")
		#else
			#set ($object = false)
			#set ($NAME = "${Type}HashMap")
			#set ($null = 0)
			#set ($equal = "(e.key == key)")
			#set ($sig = "<V>")
		#end
		#if ($l2i)
			#set ($sig = "")
		#end

#macro (INDEX $entry $mask)
#if ($object)
	${entry}.hashCode & $mask
#elseif ($type == "int")
	getHashCode (${entry}.key) & $mask
#else
	getHashCode (${entry}.key) & $mask
#end
#end

		#set ($out = "de/grogra/xl/util/${NAME}.java")
		$generator.parse("de/grogra/xl/util/HashMap.vm", $out)
	#end
#else

$pp.autogenerated

/*
 * Copyright (C) 2002 - 2007 Lehrstuhl Grafische Systeme, BTU Cottbus
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package de.grogra.xl.util;

import java.util.Iterator;

public class ${NAME}${sig} implements Iterable<${NAME}.Entry${sig}>
{
	public static class Entry${sig}
	{
#if ($object)
		final ${NAME}${sig} map;
		final int hashCode;
#end
		final $type key;
		$V value;
		Entry${sig} next;


#if ($object)
		public void remove ()
		{
			map.remove (this);
		}


		Entry (${NAME}${sig} map, int hashCode, K key, $V value)
		{
			this.map = map;
			this.hashCode = hashCode;
#else
		Entry ($type key, $V value)
		{
#end
			this.key = key;
			this.value = value;
		}
	

		public Entry${sig} next ()
		{
			Entry${sig} e = next;
			while (e != null)
			{
#if ($object)
	            if ((e.hashCode == hashCode) && map.equals (key, e.key))
#else
				if (e.key == key)
#end
	            {
	            	return e;
	            }
				e = e.next;
			}
			return null;
		}


		public $type getKey ()
		{
			return key;
		}

		
		public $V getValue ()
		{
			return value;
		}

		
		public $V setValue ($V newValue)
		{
			$V old = value;
			value = newValue;
			return old;
		}

		@Override
		public String toString ()
		{
			return key + "=" + value;
		}
	}


	private float loadFactor;
	private int size;
	private int resizeThreshold;
	private int lengthM1;
	private Entry${sig}[] table;

	
	public $NAME (int capacity, float loadFactor)
	{
        this.loadFactor = loadFactor;
        capacity = (int) ((capacity + 1) / loadFactor) + 2;
        int c = 1;
        while (c < capacity)
        {
            c <<= 1;
        }
        resizeThreshold = (int) (c * loadFactor);
        table = (Entry${sig}[]) new ${NAME}.Entry[c];
        lengthM1 = c - 1;
		size = 0;
	}


	public $NAME (int capacity)
	{
		this (capacity, 0.75f);
	}


	public $NAME ()
	{
		this (16, 0.75f);
	}


	public boolean isEmpty ()
	{
		return size == 0;
	}
	
	
	public int size ()
	{
		return size;
	}

	
	public void clear ()
	{
		Entry${sig}[] t = table;
		for (int i = lengthM1; i >= 0; i--)
		{
			t[i] = null;
		}
		size = 0;
	}

	
	public void add ($type key, $V value)
	{
#if ($object)
        add (new Entry${sig} (this, getHashCode (key), key, value));
#else
        add (new Entry${sig} (key, value));
#end
	}

	
	public $V put ($type key, $V value)
	{
        int hashCode = getHashCode (key);
        Entry${sig} e = table[hashCode & lengthM1]; 
        while (e != null)
        {
            if ($equal)
            {
            	$V old = e.value;
            	e.value = value;
            	return old;
            }
            e = e.next;
        }
#if ($object)
        add (new Entry${sig} (this, hashCode, key, value));
#else
        add (new Entry${sig} (key, value));
#end
        return $vnull;
	}


	private void add (Entry${sig} e)
	{
		int i = #INDEX("e" "lengthM1");
		e.next = table[i];
		table[i] = e;
        if (++size > resizeThreshold)
        {
            Entry${sig}[] t = new ${NAME}.Entry[(lengthM1 + 1) << 1];
            Entry${sig}[] old = table;
            int tlM1 = t.length - 1;
            for (int j = lengthM1; j >= 0; j--)
            {
            	e = old[j];
                if (e != null)
                {
                    old[j] = null;
                    do
                    {
                        Entry${sig} n = e.next;
						i = #INDEX("e" "tlM1");
                        e.next = t[i];
                        t[i] = e;
                        e = n;
                    } while (e != null);
                }
            }
            table = t;
            lengthM1 = tlM1;
            resizeThreshold = (int) (t.length * loadFactor);
        }
    }


	public void remove (Entry${sig} entry)
	{
		int i = #INDEX("entry" "lengthM1");
        Entry${sig} e = table[i], prev = null;
        while (e != null)
        {
            if (e == entry)
            {
            	size--;
            	if (prev != null)
            	{
            		prev.next = e.next;
            	}
            	else
            	{
            		table[i] = e.next;
            	}
            	return;
            }
            prev = e;
            e = e.next;
        }
	}


	public $V remove ($type key)
	{
		int hashCode = getHashCode (key);
		int i = hashCode & lengthM1;
        Entry${sig} e = table[i], prev = null;
        while (e != null)
        {
            if ($equal)
            {
            	size--;
            	if (prev != null)
            	{
            		prev.next = e.next;
            	}
            	else
            	{
            		table[i] = e.next;
            	}
            	return e.value;
            }
            prev = e;
            e = e.next;
        }
        return $vnull;
	}


	public $V remove ($type key, $V value)
	{
		int hashCode = getHashCode (key);
		int i = hashCode & lengthM1;
        Entry${sig} e = table[i], prev = null;
        while (e != null)
        {
            if ((value == e.value) && $equal)
            {
            	size--;
            	if (prev != null)
            	{
            		prev.next = e.next;
            	}
            	else
            	{
            		table[i] = e.next;
            	}
            	return e.value;
            }
            prev = e;
            e = e.next;
        }
        return $vnull;
	}


	public void removeAll ($type key)
	{
		int hashCode = getHashCode (key);
		int i = hashCode & lengthM1;
        Entry${sig} e = table[i], prev = null;
        while (e != null)
        {
            if ($equal)
            {
            	size--;
            	if (prev != null)
            	{
            		prev.next = e.next;
            	}
            	else
            	{
            		table[i] = e.next;
            	}
            }
            else
            {
                prev = e;
            }
            e = e.next;
        }
	}

	
	public Entry getEntry ($type key)
	{
		int hashCode = getHashCode (key);
        Entry${sig} e = table[hashCode & lengthM1];
        while (e != null)
        {
            if ($equal)
            {
            	return e;
            }
            e = e.next;
        }
        return null;
	}


	public $V get ($type key)
	{
		Entry${sig} e = getEntry (key);
		return (e != null) ? e.value : $vnull;
	}

#if ($l2i)
	public int get ($type key, int defaultValue)
#else
	public Object get ($type key, Object defaultValue)
#end
	{
		Entry${sig} e = getEntry (key);
		return (e != null) ? e.value : defaultValue;
	}

	public boolean containsKey ($type key)
	{
		return getEntry (key) != null;
	}


#if ($object)	

	protected int getHashCode (K o)
	{
		if (o == null)
		{
			return 0;
		}
		int h = o.hashCode();
		h ^= (h >> 20) ^ (h >> 12);
		return h ^ (h >> 7) ^ (h >> 4);
	}

	protected boolean equals (K a, K b)
	{
		return (a == b) || ((a != null) && a.equals (b));
	}

#elseif ($type == "int")

	static int getHashCode (int h)
	{
		h ^= (h >> 20) ^ (h >> 12);
		return h ^ (h >> 7) ^ (h >> 4);
	}

#else

	static int getHashCode (long k)
	{
		int h = (int) k ^ (int) (k >> 32);
		h ^= (h >> 20) ^ (h >> 12);
		return h ^ (h >> 7) ^ (h >> 4);
	}

#end

	public Iterator<Entry$sig> iterator ()
	{
		return new Iterator<Entry${sig}> ()
		{
			private int index = -1;
			private Entry${sig} next;
			private Entry${sig} current;

			public boolean hasNext ()
			{
				while (next == null)
				{
					if (++index > lengthM1)
					{
						return false;
					}
					next = table[index];
				}
				return next != null;
			}

			public Entry${sig} next ()
			{
				if (!hasNext ())
				{
					return null;
				}
				current = next;
				next = current.next;
				return current;
			}

			public void remove ()
			{
				${NAME}.this.remove (current);
			}
		};
	}

}

#end
