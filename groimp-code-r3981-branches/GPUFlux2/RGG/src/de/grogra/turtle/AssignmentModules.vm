#if (!$generate)
	#set ($generate = true)
	#foreach ($i in ["D", "L", "N", "V", "C", "P", "H", "U"])
		#if ($i == "P")
			#set ($list = ["0", "", "l"])
		#else
			#set ($list = ["0", "", "Add", "Mul", "l", "lAdd", "lMul"])
		#end
		#foreach ($j in $list)
			#set ($k = "$i$j")
			#set ($out = "de/grogra/turtle/${k}.java")
			$generator.parse("de/grogra/turtle/AssignmentModules.vm", $out)
		#end
	#end
#else

$pp.autogenerated

#set ($ROUND = "")
#if ($i == "D")
	#set ($param = "diameter")
#elseif ($i == "L")
	#set ($param = "length")
#elseif ($i == "N")
	#set ($param = "parameter")
#elseif ($i == "V")
	#set ($param = "tropism")
#elseif ($i == "C")
	#set ($param = "carbon")
#elseif ($i == "H")
	#set ($param = "heartwood")
#elseif ($i == "U")
	#set ($param = "internodeCount")
	#set ($ROUND = "Math.round")
#elseif ($i == "P")
	#set ($param = "color")
	#set ($ROUND = "Math.round")
#end
#set ($local = "local$pp.firstToUpperCase($param)")
#set ($arg = "getArgument (node, gs)")

/*
 * Copyright (C) 2002 - 2007 Lehrstuhl Grafische Systeme, BTU Cottbus
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

package de.grogra.turtle;

import de.grogra.graph.*;

#if (($i == "P") && ($j != "0"))
#set ($shader = true)
import de.grogra.imp3d.shading.*;
#else
#set ($shader = false)
#end

/**
 * The turtle command
#if ($j == "0")
 * <code>$k</code>
#else
 * <code>$k(x)</code>
#end
#if ($j.startsWith("l"))
 * sets {@link de.grogra.turtle.TurtleState#$local} to
#if ($j == "lAdd")
 * the sum of {@link de.grogra.turtle.TurtleState#$param} and
#elseif ($j == "lMul")
 * the product of the field {@link de.grogra.turtle.TurtleState#$param} and
#end
 * the specified {@link de.grogra.turtle.Assignment#argument argument}
 * <code>x</code>.
#else
#if ($j == "0")
 * resets {@link de.grogra.turtle.TurtleState#$param} to its initial value
 * (as defined in {@link de.grogra.turtle.TurtleState#initialState}).
#else
#if ($j == "Add")
 * increments {@link de.grogra.turtle.TurtleState#$param} by
#elseif ($j == "Mul")
 * multiplies {@link de.grogra.turtle.TurtleState#$param} by
#else
 * sets {@link de.grogra.turtle.TurtleState#$param} to
#end
 * the specified {@link de.grogra.turtle.Assignment#argument argument}
 * <code>x</code>.
#end
 * Then the value of <code>$param</code> is copied to
 * its local counterpart {@link de.grogra.turtle.TurtleState#$local}.
#end
 * <br>
#if ($j.startsWith("l"))
#set ($gg = "${i}l")
#else
#set ($gg = "$i")
#end
#if ($j.endsWith("Add"))
#set ($gg = "${gg}+")
#elseif ($j.endsWith("Mul"))
#set ($gg = "${gg}*")
#end
#if ($j != "0")
#set ($gg = "${gg}(x)")
#end
 * This corresponds to the turtle command <code>$gg</code>
 * of the GROGRA software.
#if ($i == "P")
 * <br>
#if ($j == "0")
 * In addition, this command clears
#else
 * There exists an extended command
 * <code>$k(s)</code> where <code>s</code> is a <code>Shader</code>.
 * This sets the field {@link #shader}, which is
 * in turn used to set
#end
#if ($j != "l")
 * {@link de.grogra.turtle.TurtleState#shader} and
#end
 * {@link de.grogra.turtle.TurtleState#localShader}.
#end
 *
 * @author Ole Kniemeyer
 */
public class $k extends
#if ($j == "0")
	de.grogra.graph.impl.Node implements TurtleModifier
#else
	Assignment
#end
{
#if ($shader)
	public Shader shader = null;
	//enh:field attr=Attributes.SHADER getter setter


	public void setShaders (Shader front, Shader back)
	{
		setShader (new SideSwitchShader (front, back));
	}
	
	
	public $k (Shader shader)
	{
		super (-1);
		setShader (shader);
	}


	public $k (Shader front, Shader back)
	{
		super (-1);
		setShaders (front, back);
	}

#end
#if ($k == "P")
	public P (int argument)
	{
		super ((argument == (argument & 15)) ? argument : -1);
		shader = (argument == (argument & 15)) ? RGBAShader.forEGAColor (argument)
			: new RGBAShader (argument | 0xff000000);
	}
#end

#if ($j == "0")

	private static void initType ()
	{
		$TYPE.addIdentityAccessor (Attributes.TURTLE_MODIFIER);
	}

	//enh:insert initType ();

#else

#if ($shader)

	private static void initType ()
	{
		$TYPE.addDependency (Attributes.SHADER, Attributes.TURTLE_MODIFIER);
	}

	//enh:insert initType ();

#else

	//enh:insert
	
#end

	public static class Pattern extends de.grogra.xl.impl.base.FieldListPattern
	{
		public Pattern ()
		{
			super (${k}.$TYPE, argument$FIELD);
		}

		public static void signature (@In @Out ${k} n, float a)
		{
		}
	}


	public $k ()
	{
		this (0);
	}


	public $k (float argument)
	{
		super (argument);
	}
#end


	public void execute (Object node, TurtleState state, GraphState gs)
	{
#if ($j == "0")
		state.$local = state.$param = state.initialState.$param;
#if ($i == "P")
		state.localShader = state.shader = null;
#end
#elseif ($j == "Add")
		state.$local = state.$param = $ROUND (state.$param + $arg);
#elseif ($j == "Mul")
		state.$local = state.$param = $ROUND (state.$param * $arg);
#elseif ($j == "l")
		state.$local = $ROUND ($arg);
#if ($i == "P")
		state.localShader = shader;
#end
#elseif ($j == "lAdd")
		state.$local = $ROUND (state.$param + $arg);
#elseif ($j == "lMul")
		state.$local = $ROUND (state.$param * $arg);
#else
		state.$local = state.$param = $ROUND ($arg);
#if ($i == "P")
		state.localShader = state.shader = shader;
#end
#end
	}
}
#end
